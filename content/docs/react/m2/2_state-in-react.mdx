---
title: "State in React"
description:
   "See how React stores, updates, and re-renders stateful data inside TaskFlow
   Pro."
module: "M2"
lesson: "2"
difficulty: "beginner"
duration: "25"
project_phase: "Interactivity"
prerequisites: ["/docs/react/m2/1_introduction-state"]
learning_objectives:
   - "Describe how React queues state updates"
   - "Use functional updates to avoid stale closures"
   - "Compose state with derived selectors for TaskFlow Pro"
tags: ["state", "react", "functional-updates"]
---

import { Accordions, Accordion } from "@/components/accordion";

# State in React

## Learning Objectives

By the end of this lesson, you will:

-  [ ] Explain how React batches state updates in the same tick.
-  [ ] Use functional updates to compute the next state from the previous one.
-  [ ] Derive counts and summaries from the task list.
-  [ ] Plan selectors that drive TaskFlow Pro metrics.

## Project Context

Tasks, filters, and modals will rely on state updates every time a user edits a
task. Understanding React's update queue prevents race conditions and stale
reads in TaskFlow Pro.

---

## How React Updates State

React batches state updates during event handlers. Each call to `setState`
triggers reconciliation with the latest value, not the one visible when the
handler started.

### Basic Example

```tsx
setCount((previous) => previous + 1);
```

### Practical Example

```tsx
setTasks((previous) =>
   previous.map((task) =>
      task.id === id ? { ...task, status: nextStatus } : task
   )
);
```

---

## Deriving Data from State

Rather than storing counts or filtered lists separately, derive them during
render or memoize them.

```tsx
const completedCount = useMemo(
   () => tasks.filter((task) => task.status === "done").length,
   [tasks]
);
```

This keeps UI metrics in sync regardless of how tasks mutate.

---

## ✅ Best Practices

### 1. Prefer Functional Updates

**Why:** Ensures the latest state is used when multiple updates occur quickly.

```tsx
setComposerState((previous) => ({
   ...previous,
   title: event.target.value,
}));
```

### 2. Memoize Expensive Selectors

**Why:** Avoids recomputing filtered lists during every render.

```tsx
const highPriorityTasks = useMemo(
   () => tasks.filter((task) => task.priority === "high"),
   [tasks]
);
```

---

## ❌ Common Mistakes

### 1. Mutating State In Place

**Problem:** React cannot detect changes when references stay the same.

```tsx
// Bad
tasks.push(newTask);
setTasks(tasks);
```

**Solution:** Return a new array.

```tsx
setTasks((previous) => [...previous, newTask]);
```

### 2. Deriving State During Submission

**Problem:** You risk using outdated values while React is still reconciling.

**Solution:** Let the render cycle compute derived data instead of doing it
inside event handlers.

---

## 🔨 Implement in TaskFlow Pro

### Task: Build a State Visualizer

1. Create `src/sandbox/state-visualizer.tsx`.
2. Implement a `StateVisualizer` component that:
   -  Uses `useState` to store an array of sample tasks
   -  Provides buttons to add, complete, or delete tasks
   -  Computes derived counts (`total`, `completed`, `remaining`) with `useMemo`
3. Render the component in the sandbox area below the JSX playground from
   Module 1.
4. Commit with `git commit -am "chore: add state visualizer sandbox"`.

<Accordions type='single' className='mt-4'>
   <Accordion title='Solution Walkthrough'>
      <p>
         Create an isolated playground to practice state updates before wiring them into
         the main dashboard.
      </p>

      ```tsx filename="src/sandbox/state-visualizer.tsx"
      import { useMemo, useState } from 'react';
      import type { Task } from '@/types/task';

      const seedTasks: Task[] = [
         {
            id: 'demo-1',
            title: 'Draft task composer copy',
            summary: 'Outline headings for the composer card.',
            status: 'todo',
            priority: 'medium',
         },
      ];

      export function StateVisualizer() {
         const [tasks, setTasks] = useState<Task[]>(seedTasks);

         const totals = useMemo(() => {
            const completed = tasks.filter((task) => task.status === 'done').length;
            return {
               total: tasks.length,
               completed,
               remaining: tasks.length - completed,
            };
         }, [tasks]);

         const addTask = () => {
            setTasks((previous) => [
               ...previous,
               {
                  id: `demo-${previous.length + 1}`,
                  title: `Sandbox task ${previous.length + 1}`,
                  summary: 'Experimenting with state updates',
                  status: 'todo',
                  priority: 'low',
               },
            ]);
         };

         const toggleStatus = (taskId: string) => {
            setTasks((previous) =>
               previous.map((task) =>
                  task.id === taskId
                     ? {
                          ...task,
                          status: task.status === 'done' ? 'todo' : 'done',
                       }
                     : task,
               ),
            );
         };

         const deleteTask = (taskId: string) => {
            setTasks((previous) => previous.filter((task) => task.id !== taskId));
         };

         return (
            <section className='rounded-xl border border-dashed border-primary/40 bg-card p-6 shadow-sm'>
               <header className='flex flex-wrap items-center justify-between gap-4'>
                  <h2 className='text-lg font-semibold text-foreground'>State Visualizer</h2>
                  <button
                     type='button'
                     onClick={addTask}
                     className='rounded-lg bg-primary px-3 py-2 text-sm font-medium text-primary-foreground shadow'
                  >
                     Add Sandbox Task
                  </button>
               </header>
               <div className='mt-4 flex gap-6 text-sm text-muted-foreground'>
                  <span>Total: {totals.total}</span>
                  <span>Completed: {totals.completed}</span>
                  <span>Remaining: {totals.remaining}</span>
               </div>
               <ul className='mt-4 space-y-2'>
                  {tasks.map((task) => (
                     <li key={task.id} className='flex items-center justify-between rounded-lg border border-border p-3'>
                        <span>{task.title}</span>
                        <div className='flex gap-2'>
                           <button type='button' onClick={() => toggleStatus(task.id)} className='text-xs font-medium text-primary'>
                              Toggle Status
                           </button>
                           <button type='button' onClick={() => deleteTask(task.id)} className='text-xs font-medium text-destructive'>
                              Delete
                           </button>
                        </div>
                     </li>
                  ))}
               </ul>
            </section>
         );
      }
      ```

      ```tsx filename="src/App.tsx"
      import { StateVisualizer } from '@/sandbox/state-visualizer';

      export function App() {
         return (
            <DashboardShell>
               {/* Existing layout */}
               <StateVisualizer />
            </DashboardShell>
         );
      }
      ```

      ```bash
      git add src/sandbox/state-visualizer.tsx src/App.tsx
      git commit -m "chore: add state visualizer sandbox"
      ```

   </Accordion>
</Accordions>

#### Expected Result

You have a sandbox demonstrating state updates, derived data, and event-driven
changes.

---

## ✅ Validation Checklist

### Functionality

-  [ ] Buttons add, toggle, and delete sandbox tasks correctly.
-  [ ] Derived counts update without manual refresh.

### Code Quality

-  [ ] Functional updates avoid stale reads.
-  [ ] Derived values use `useMemo`.

### Understanding

-  [ ] You can explain how React batches state updates.

### Project Integration

-  [ ] Sandbox insights feed into the Module 2 implementation plan.

---


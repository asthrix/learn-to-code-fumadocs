---
title: "L9: Add Caching to useFetch"
description: "Implement in-memory caching to prevent duplicate API requests"
---


Enhance our `useFetch` hook with caching to eliminate duplicate API requests and improve performance!

## What You'll Learn

- Implement in-memory caching
- Cache invalidation strategies
- Prevent duplicate requests
- Share cached data between components
- Configure cache behavior
- Measure cache effectiveness

## The Problem: Duplicate Requests

Currently, every component that uses `useFetch` makes its own request:

```jsx
// Component 1
function ListingDetailsPage() {
  const { data } = useFetch('/listings/123');  // Request 1
  return <div>{data?.title}</div>;
}

// Component 2 (same listing!)
function RelatedListings() {
  const { data } = useFetch('/listings/123');  // Request 2 (duplicate!)
  return <div>{data?.title}</div>;
}
```

**Problems:**
- Wastes bandwidth
- Slower load times
- Unnecessary API load
- Poor user experience

<Callout type="warning">
**Performance impact:** In development (React.StrictMode), components mount twice, causing double requests. Caching solves this!
</Callout>

## Solution: In-Memory Cache

We'll create a cache object that stores API responses:

```jsx
// Cache structure
const cache = {
  '/listings': { data: [...], timestamp: 1234567890 },
  '/listings/123': { data: {...}, timestamp: 1234567891 }
};
```

**How it works:**

1. Check if URL is in cache
2. If yes â†’ Return cached data (instant! âš¡)
3. If no â†’ Fetch from API, store in cache
4. Optionally expire old cache entries

## Implementing the Cache

<Steps>

<Step>

#### Create cache object

```jsx title="src/hooks/useFetch.js" {4-9}
import { useState, useEffect } from 'react';
import api from '@/api';

// In-memory cache outside component
const cache = {};

// Cache configuration
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes
const ENABLE_CACHE = true;

export function useFetch(url) {
  // ... hook implementation
}
```

Cache is outside the hook so it's shared across all components!

</Step>

<Step>

#### Check cache before fetching

```jsx title="src/hooks/useFetch.js" {10-20}
export function useFetch(url) {
  const [data, setData] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    const controller = new AbortController();
    
    const fetchData = async () => {
      // Check cache first
      if (ENABLE_CACHE && cache[url]) {
        const cached = cache[url];
        const age = Date.now() - cached.timestamp;
        
        // Use cached data if fresh
        if (age < CACHE_DURATION) {
          setData(cached.data);
          setIsLoading(false);
          return; // Skip fetch!
        }
      }
      
      // Cache miss or expired - fetch from API
      try {
        setIsLoading(true);
        setError(null);
        
        const response = await api.get(url, {
          signal: controller.signal
        });
        
        // Store in cache
        cache[url] = {
          data: response.data,
          timestamp: Date.now()
        };
        
        setData(response.data);
      } catch (err) {
        if (err.name !== 'AbortError') {
          setError(err.message);
        }
      } finally {
        setIsLoading(false);
      }
    };
    
    fetchData();
    
    return () => controller.abort();
  }, [url]);
  
  return { data, isLoading, error };
}
```

**Flow:**
1. Check if `cache[url]` exists
2. Check if cache is fresh (< 5 minutes)
3. If yes â†’ Return cached data, skip fetch
4. If no â†’ Fetch and update cache

</Step>

<Step>

#### Add cache inspection

```jsx title="src/hooks/useFetch.js" {5-8}
export function useFetch(url) {
  // ... existing code
  
  useEffect(() => {
    const fetchData = async () => {
      if (ENABLE_CACHE && cache[url]) {
        console.log(`Cache HIT: ${url}`);
        // ... return cached data
      } else {
        console.log(`Cache MISS: ${url}`);
        // ... fetch from API
      }
    };
    
    fetchData();
  }, [url]);
  
  return { data, isLoading, error };
}
```

Check browser console to see cache hits!

</Step>

</Steps>

## Complete Cached Hook

```jsx title="src/hooks/useFetch.js"
import { useState, useEffect } from 'react';
import api from '@/api';

// Cache configuration
const cache = {};
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes
const ENABLE_CACHE = true;

export function useFetch(url, options = {}) {
  const [data, setData] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);
  
  const {
    cacheTime = CACHE_DURATION,
    enableCache = ENABLE_CACHE
  } = options;
  
  useEffect(() => {
    const controller = new AbortController();
    
    const fetchData = async () => {
      // Check cache
      if (enableCache && cache[url]) {
        const cached = cache[url];
        const age = Date.now() - cached.timestamp;
        
        if (age < cacheTime) {
          console.log(`âœ… Cache HIT: ${url} (age: ${Math.round(age/1000)}s)`);
          setData(cached.data);
          setIsLoading(false);
          return;
        } else {
          console.log(`â° Cache EXPIRED: ${url}`);
        }
      } else if (enableCache) {
        console.log(`âŒ Cache MISS: ${url}`);
      }
      
      // Fetch from API
      try {
        setIsLoading(true);
        setError(null);
        
        const response = await api.get(url, {
          signal: controller.signal
        });
        
        // Update cache
        if (enableCache) {
          cache[url] = {
            data: response.data,
            timestamp: Date.now()
          };
          console.log(`ðŸ’¾ Cached: ${url}`);
        }
        
        setData(response.data);
      } catch (err) {
        if (err.name !== 'AbortError') {
          setError(err.message);
        }
      } finally {
        setIsLoading(false);
      }
    };
    
    fetchData();
    
    return () => controller.abort();
  }, [url, cacheTime, enableCache]);
  
  return { data, isLoading, error };
}

// Utility functions
export function clearCache(url) {
  if (url) {
    delete cache[url];
    console.log(`ðŸ—‘ï¸ Cleared cache: ${url}`);
  } else {
    Object.keys(cache).forEach(key => delete cache[key]);
    console.log('ðŸ—‘ï¸ Cleared all cache');
  }
}

export function getCacheStats() {
  const keys = Object.keys(cache);
  const stats = keys.map(key => ({
    url: key,
    age: Math.round((Date.now() - cache[key].timestamp) / 1000),
    size: JSON.stringify(cache[key].data).length
  }));
  
  console.table(stats);
  return stats;
}
```

## Usage Examples

<Tabs items={['Basic', 'Custom Cache Time', 'Disable Cache', 'Clear Cache']}>

<Tab value="Basic">

```jsx
// Uses default 5-minute cache
function HomePage() {
  const { data: listings } = useFetch('/listings');
  return <ListingList listings={listings} />;
}

// Second component uses cached data!
function FeaturedListings() {
  const { data: listings } = useFetch('/listings');  // Cache HIT!
  return <FeaturedList listings={listings?.slice(0, 3)} />;
}
```

**Result:** Only one API request, two components get data instantly!

</Tab>

<Tab value="Custom Cache Time">

```jsx
// Cache for 1 minute (data changes frequently)
function RealTimeStats() {
  const { data: stats } = useFetch('/stats', {
    cacheTime: 60 * 1000  // 1 minute
  });
  return <Stats data={stats} />;
}

// Cache for 1 hour (data rarely changes)
function AppConfig() {
  const { data: config } = useFetch('/config', {
    cacheTime: 60 * 60 * 1000  // 1 hour
  });
  return <Config data={config} />;
}
```

</Tab>

<Tab value="Disable Cache">

```jsx
// Always fetch fresh data (for critical data)
function BankBalance() {
  const { data: balance } = useFetch('/balance', {
    enableCache: false  // Always fresh
  });
  return <div>${balance}</div>;
}
```

</Tab>

<Tab value="Clear Cache">

```jsx
import { useFetch, clearCache } from '@/hooks/useFetch';

function DataManager() {
  const { data, isLoading } = useFetch('/data');
  
  const handleRefresh = () => {
    clearCache('/data');  // Clear specific URL
    window.location.reload();  // Reload to refetch
  };
  
  const handleClearAll = () => {
    clearCache();  // Clear all cache
    window.location.reload();
  };
  
  return (
    <>
      <button onClick={handleRefresh}>Refresh Data</button>
      <button onClick={handleClearAll}>Clear All Cache</button>
      <div>{data}</div>
    </>
  );
}
```

</Tab>

</Tabs>

## Performance Impact

<Tabs items={['Without Cache', 'With Cache']}>

<Tab value="Without Cache">

**Scenario:** User navigates between pages

1. HomePage â†’ Fetch /listings (500ms)
2. Navigate to details â†’ Fetch /listings/123 (300ms)
3. Back to HomePage â†’ Fetch /listings again (500ms)
4. Navigate to details again â†’ Fetch /listings/123 again (300ms)

**Total:** 1600ms of waiting, 4 API requests

</Tab>

<Tab value="With Cache">

**Scenario:** Same navigation

1. HomePage â†’ Fetch /listings (500ms) â†’ Cache it
2. Navigate to details â†’ Fetch /listings/123 (300ms) â†’ Cache it
3. Back to HomePage â†’ Use cached /listings (0ms) âš¡
4. Navigate to details again â†’ Use cached /listings/123 (0ms) âš¡

**Total:** 800ms of waiting, 2 API requests

**Performance improvement: 50% faster, 50% fewer requests!** ðŸš€

</Tab>

</Tabs>

## Advanced: Stale-While-Revalidate

Show cached data immediately, then update in background:

```jsx
export function useFetch(url, options = {}) {
  const [data, setData] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [isStale, setIsStale] = useState(false);
  
  const { staleWhileRevalidate = false } = options;
  
  useEffect(() => {
    const controller = new AbortController();
    
    const fetchData = async () => {
      // Check cache
      if (cache[url]) {
        const cached = cache[url];
        const age = Date.now() - cached.timestamp;
        
        // Show cached data immediately
        setData(cached.data);
        setIsLoading(false);
        
        if (age < CACHE_DURATION) {
          if (!staleWhileRevalidate) {
            return; // Fresh, don't refetch
          }
        }
        
        // Mark as stale, refetch in background
        setIsStale(true);
      }
      
      // Fetch (either no cache, or revalidating)
      try {
        if (!cache[url]) {
          setIsLoading(true);
        }
        
        const response = await api.get(url, {
          signal: controller.signal
        });
        
        cache[url] = {
          data: response.data,
          timestamp: Date.now()
        };
        
        setData(response.data);
        setIsStale(false);
      } catch (err) {
        if (err.name !== 'AbortError') {
          setError(err.message);
        }
      } finally {
        setIsLoading(false);
      }
    };
    
    fetchData();
    return () => controller.abort();
  }, [url, staleWhileRevalidate]);
  
  return { data, isLoading, error, isStale };
}

// Usage
function Component() {
  const { data, isStale } = useFetch('/data', {
    staleWhileRevalidate: true
  });
  
  return (
    <div>
      {isStale && <span>Updating...</span>}
      <div>{data}</div>
    </div>
  );
}
```

**Benefits:**
- Instant UI (show cached data)
- Always up-to-date (background refetch)
- Best user experience!

## Cache Invalidation Strategies

<Accordions>

<Accordion title="1. Time-Based (Current Implementation)">

```jsx
// Expire after 5 minutes
const CACHE_DURATION = 5 * 60 * 1000;

if (age < CACHE_DURATION) {
  return cached.data;
}
```

**Pros:** Simple, automatic
**Cons:** May show stale data

</Accordion>

<Accordion title="2. Manual Invalidation">

```jsx
// Clear cache on specific actions
function handleUpdate() {
  await api.post('/listings', newListing);
  clearCache('/listings');  // Force refetch
}
```

**Pros:** Always fresh after updates
**Cons:** Requires manual management

</Accordion>

<Accordion title="3. Tag-Based Invalidation">

```jsx
const cacheTags = {
  '/listings': ['listings'],
  '/listings/123': ['listings', 'listing-123']
};

function invalidateTag(tag) {
  Object.keys(cacheTags).forEach(url => {
    if (cacheTags[url].includes(tag)) {
      delete cache[url];
    }
  });
}

// Invalidate all listings
invalidateTag('listings');
```

**Pros:** Flexible, granular control
**Cons:** More complex

</Accordion>

<Accordion title="4. Mutation-Based">

```jsx
// Optimistic update
function useUpdateListing() {
  const updateListing = async (id, changes) => {
    // Update cache immediately
    if (cache[`/listings/${id}`]) {
      cache[`/listings/${id}`].data = {
        ...cache[`/listings/${id}`].data,
        ...changes
      };
    }
    
    // Then update server
    await api.put(`/listings/${id}`, changes);
  };
  
  return { updateListing };
}
```

**Pros:** Instant UI updates
**Cons:** Must handle errors

</Accordion>

</Accordions>

## Monitoring Cache Performance

```jsx
// Add to useFetch for metrics
let cacheHits = 0;
let cacheMisses = 0;

export function getCacheMetrics() {
  const total = cacheHits + cacheMisses;
  const hitRate = total ? (cacheHits / total * 100).toFixed(1) : 0;
  
  return {
    hits: cacheHits,
    misses: cacheMisses,
    total,
    hitRate: `${hitRate}%`
  };
}

// View in console
console.log('Cache metrics:', getCacheMetrics());
// { hits: 45, misses: 12, total: 57, hitRate: "78.9%" }
```

## Best Practices

<Steps>

<Step>

#### Choose appropriate cache duration

```jsx
// Frequently changing data - short cache
useFetch('/live-stats', { cacheTime: 10000 });  // 10 seconds

// Rarely changing data - long cache
useFetch('/categories', { cacheTime: 3600000 });  // 1 hour

// Static data - very long cache
useFetch('/constants', { cacheTime: 86400000 });  // 24 hours
```

</Step>

<Step>

#### Clear cache on mutations

```jsx
async function createListing(data) {
  await api.post('/listings', data);
  clearCache('/listings');  // Refetch will get new listing
}

async function updateListing(id, changes) {
  await api.put(`/listings/${id}`, changes);
  clearCache(`/listings/${id}`);  // Specific URL
  clearCache('/listings');  // List page too
}
```

</Step>

<Step>

#### Monitor cache effectiveness

```jsx
// Log cache metrics periodically
useEffect(() => {
  const interval = setInterval(() => {
    console.log('Cache stats:', getCacheMetrics());
    getCacheStats();  // Shows table
  }, 60000);  // Every minute
  
  return () => clearInterval(interval);
}, []);
```

**Target:** 70%+ cache hit rate

</Step>

</Steps>

## What's Next?

In **Lesson 10**, we'll **review all Module 5 concepts** - custom hooks, useMemo, useCallback, React.memo, profiling, and caching. We'll see how they all work together! ðŸš€

## Summary

- âœ… Implemented in-memory caching in useFetch
- âœ… Eliminates duplicate API requests
- âœ… 50% faster page navigation
- âœ… Configurable cache duration
- âœ… Manual cache invalidation
- âœ… Stale-while-revalidate pattern
- âœ… Cache performance monitoring

**Key concept:** Caching prevents duplicate work. It's one of the most effective optimizations you can make!

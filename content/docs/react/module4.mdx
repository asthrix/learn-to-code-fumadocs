---
title: Module 4 - Effects & Component Lifecycle
description:
   Master useEffect hook, component lifecycle, side effects, and data fetching
   in React
---

# Module 4: Effects & Component Lifecycle

In this module, we'll explore the `useEffect` hook, which allows you to perform
side effects in function components. You'll learn about component lifecycle,
data fetching, cleanup, and performance optimization.

## Introduction to useEffect

The `useEffect` hook lets you perform side effects in function components. It
serves the same purpose as `componentDidMount`, `componentDidUpdate`, and
`componentWillUnmount` combined in class components.

### Basic useEffect Syntax

```jsx
import React, { useState, useEffect } from "react";

function BasicEffect() {
   const [count, setCount] = useState(0);

   // Effect runs after every render
   useEffect(() => {
      document.title = `Count: ${count}`;
   });

   return (
      <div>
         <p>You clicked {count} times</p>
         <button onClick={() => setCount(count + 1)}>Click me</button>
      </div>
   );
}
```

## Effect Dependencies

Control when effects run using the dependency array:

### 1. No Dependencies (Runs After Every Render)

```jsx
function EveryRender() {
   const [count, setCount] = useState(0);

   useEffect(() => {
      console.log("This runs after every render");
   }); // No dependency array

   return (
      <div>
         <p>Count: {count}</p>
         <button onClick={() => setCount(count + 1)}>Increment</button>
      </div>
   );
}
```

### 2. Empty Dependencies (Runs Once on Mount)

```jsx
function OnMount() {
   const [data, setData] = useState(null);

   useEffect(() => {
      console.log("This runs only once on mount");
      // Perfect for initial data fetching
      fetchInitialData();
   }, []); // Empty dependency array

   const fetchInitialData = async () => {
      // Simulate API call
      setTimeout(() => {
         setData("Initial data loaded!");
      }, 1000);
   };

   return (
      <div>
         <p>{data || "Loading..."}</p>
      </div>
   );
}
```

### 3. Specific Dependencies (Runs When Dependencies Change)

```jsx
function SpecificDependencies() {
   const [count, setCount] = useState(0);
   const [name, setName] = useState("");

   useEffect(() => {
      console.log("This runs only when count changes");
      document.title = `Count: ${count}`;
   }, [count]); // Only re-run when count changes

   return (
      <div>
         <p>Count: {count}</p>
         <button onClick={() => setCount(count + 1)}>Increment</button>

         <input
            type='text'
            value={name}
            onChange={(e) => setName(e.target.value)}
            placeholder='Type your name'
         />
         <p>Name: {name}</p>
      </div>
   );
}
```

## Data Fetching with useEffect

### Basic API Fetch

```jsx
function UserProfile({ userId }) {
   const [user, setUser] = useState(null);
   const [loading, setLoading] = useState(true);
   const [error, setError] = useState(null);

   useEffect(() => {
      const fetchUser = async () => {
         try {
            setLoading(true);
            setError(null);

            // Simulate API call
            const response = await fetch(
               `https://jsonplaceholder.typicode.com/users/${userId}`
            );

            if (!response.ok) {
               throw new Error("Failed to fetch user");
            }

            const userData = await response.json();
            setUser(userData);
         } catch (err) {
            setError(err.message);
         } finally {
            setLoading(false);
         }
      };

      fetchUser();
   }, [userId]); // Re-fetch when userId changes

   if (loading) return <div>Loading user...</div>;
   if (error) return <div>Error: {error}</div>;
   if (!user) return <div>No user found</div>;

   return (
      <div
         style={{
            border: "1px solid #ddd",
            borderRadius: "8px",
            padding: "20px",
            maxWidth: "400px",
            margin: "20px auto",
         }}
      >
         <h2>{user.name}</h2>
         <p>
            <strong>Email:</strong> {user.email}
         </p>
         <p>
            <strong>Phone:</strong> {user.phone}
         </p>
         <p>
            <strong>Website:</strong> {user.website}
         </p>
         <p>
            <strong>Company:</strong> {user.company?.name}
         </p>
      </div>
   );
}

// Usage
function App() {
   const [selectedUserId, setSelectedUserId] = useState(1);

   return (
      <div>
         <div style={{ textAlign: "center", marginBottom: "20px" }}>
            <h1>User Profiles</h1>
            <select
               value={selectedUserId}
               onChange={(e) => setSelectedUserId(Number(e.target.value))}
               style={{ padding: "8px", fontSize: "16px" }}
            >
               {[1, 2, 3, 4, 5].map((id) => (
                  <option key={id} value={id}>
                     User {id}
                  </option>
               ))}
            </select>
         </div>
         <UserProfile userId={selectedUserId} />
      </div>
   );
}
```

### Posts List with Pagination

```jsx
function PostsList() {
   const [posts, setPosts] = useState([]);
   const [loading, setLoading] = useState(false);
   const [page, setPage] = useState(1);
   const [hasMore, setHasMore] = useState(true);

   useEffect(() => {
      const fetchPosts = async () => {
         try {
            setLoading(true);

            const response = await fetch(
               `https://jsonplaceholder.typicode.com/posts?_page=${page}&_limit=10`
            );

            const newPosts = await response.json();

            if (newPosts.length === 0) {
               setHasMore(false);
            } else {
               setPosts((prevPosts) => [...prevPosts, ...newPosts]);
            }
         } catch (error) {
            console.error("Failed to fetch posts:", error);
         } finally {
            setLoading(false);
         }
      };

      fetchPosts();
   }, [page]);

   const loadMore = () => {
      if (!loading && hasMore) {
         setPage((prevPage) => prevPage + 1);
      }
   };

   return (
      <div style={{ maxWidth: "800px", margin: "0 auto", padding: "20px" }}>
         <h1>Blog Posts</h1>

         <div>
            {posts.map((post) => (
               <article
                  key={post.id}
                  style={{
                     border: "1px solid #ddd",
                     borderRadius: "8px",
                     padding: "16px",
                     marginBottom: "16px",
                     backgroundColor: "#f9f9f9",
                  }}
               >
                  <h3 style={{ color: "#333", textTransform: "capitalize" }}>
                     {post.title}
                  </h3>
                  <p style={{ color: "#666", lineHeight: "1.6" }}>
                     {post.body}
                  </p>
                  <small style={{ color: "#999" }}>Post #{post.id}</small>
               </article>
            ))}
         </div>

         {hasMore && (
            <div style={{ textAlign: "center", marginTop: "20px" }}>
               <button
                  onClick={loadMore}
                  disabled={loading}
                  style={{
                     backgroundColor: loading ? "#ccc" : "#007bff",
                     color: "white",
                     border: "none",
                     padding: "12px 24px",
                     borderRadius: "4px",
                     cursor: loading ? "not-allowed" : "pointer",
                     fontSize: "16px",
                  }}
               >
                  {loading ? "Loading..." : "Load More Posts"}
               </button>
            </div>
         )}

         {!hasMore && (
            <p style={{ textAlign: "center", color: "#666" }}>
               No more posts to load.
            </p>
         )}
      </div>
   );
}
```

## Cleanup and Memory Management

### Cleanup Functions

```jsx
function Timer() {
   const [seconds, setSeconds] = useState(0);
   const [isRunning, setIsRunning] = useState(false);

   useEffect(() => {
      let interval = null;

      if (isRunning) {
         interval = setInterval(() => {
            setSeconds((prevSeconds) => prevSeconds + 1);
         }, 1000);
      }

      // Cleanup function - runs when component unmounts or dependencies change
      return () => {
         if (interval) {
            clearInterval(interval);
         }
      };
   }, [isRunning]);

   const reset = () => {
      setSeconds(0);
      setIsRunning(false);
   };

   return (
      <div style={{ textAlign: "center", padding: "20px" }}>
         <h2>Timer: {seconds}s</h2>
         <div style={{ margin: "20px 0" }}>
            <button
               onClick={() => setIsRunning(!isRunning)}
               style={{
                  backgroundColor: isRunning ? "#dc3545" : "#28a745",
                  color: "white",
                  border: "none",
                  padding: "10px 20px",
                  borderRadius: "4px",
                  cursor: "pointer",
                  marginRight: "10px",
                  fontSize: "16px",
               }}
            >
               {isRunning ? "Stop" : "Start"}
            </button>
            <button
               onClick={reset}
               style={{
                  backgroundColor: "#6c757d",
                  color: "white",
                  border: "none",
                  padding: "10px 20px",
                  borderRadius: "4px",
                  cursor: "pointer",
                  fontSize: "16px",
               }}
            >
               Reset
            </button>
         </div>
      </div>
   );
}
```

### Event Listeners Cleanup

```jsx
function WindowSize() {
   const [windowSize, setWindowSize] = useState({
      width: window.innerWidth,
      height: window.innerHeight,
   });

   useEffect(() => {
      const handleResize = () => {
         setWindowSize({
            width: window.innerWidth,
            height: window.innerHeight,
         });
      };

      // Add event listener
      window.addEventListener("resize", handleResize);

      // Cleanup: Remove event listener
      return () => {
         window.removeEventListener("resize", handleResize);
      };
   }, []); // Empty dependency array - only run once

   return (
      <div
         style={{
            textAlign: "center",
            padding: "20px",
            border: "2px solid #007bff",
            borderRadius: "8px",
            margin: "20px",
         }}
      >
         <h3>Window Size</h3>
         <p>Width: {windowSize.width}px</p>
         <p>Height: {windowSize.height}px</p>
         <small>Resize your window to see live updates!</small>
      </div>
   );
}
```

## Real-World Examples

### Search with Debouncing

```jsx
function SearchUsers() {
   const [query, setQuery] = useState("");
   const [users, setUsers] = useState([]);
   const [loading, setLoading] = useState(false);
   const [error, setError] = useState(null);

   useEffect(() => {
      // Don't search for empty queries
      if (!query.trim()) {
         setUsers([]);
         return;
      }

      // Debounce search - wait 500ms after user stops typing
      const timeoutId = setTimeout(async () => {
         try {
            setLoading(true);
            setError(null);

            // Simulate API search
            const response = await fetch(
               `https://jsonplaceholder.typicode.com/users?name_like=${query}`
            );

            if (!response.ok) {
               throw new Error("Search failed");
            }

            const searchResults = await response.json();
            setUsers(searchResults);
         } catch (err) {
            setError(err.message);
            setUsers([]);
         } finally {
            setLoading(false);
         }
      }, 500);

      // Cleanup: Cancel previous timeout
      return () => clearTimeout(timeoutId);
   }, [query]);

   return (
      <div style={{ maxWidth: "600px", margin: "0 auto", padding: "20px" }}>
         <h2>Search Users</h2>

         <input
            type='text'
            value={query}
            onChange={(e) => setQuery(e.target.value)}
            placeholder='Search users by name...'
            style={{
               width: "100%",
               padding: "12px",
               border: "2px solid #ddd",
               borderRadius: "8px",
               fontSize: "16px",
               marginBottom: "20px",
            }}
         />

         {loading && (
            <div style={{ textAlign: "center", padding: "20px" }}>
               <p>Searching...</p>
            </div>
         )}

         {error && (
            <div
               style={{
                  color: "#dc3545",
                  padding: "10px",
                  backgroundColor: "#f8d7da",
                  border: "1px solid #f5c6cb",
                  borderRadius: "4px",
                  marginBottom: "20px",
               }}
            >
               Error: {error}
            </div>
         )}

         <div>
            {users.length > 0 ? (
               <ul style={{ listStyle: "none", padding: 0 }}>
                  {users.map((user) => (
                     <li
                        key={user.id}
                        style={{
                           border: "1px solid #ddd",
                           borderRadius: "8px",
                           padding: "16px",
                           marginBottom: "12px",
                           backgroundColor: "#f9f9f9",
                        }}
                     >
                        <h4 style={{ margin: "0 0 8px 0" }}>{user.name}</h4>
                        <p style={{ margin: "4px 0", color: "#666" }}>
                           Email: {user.email}
                        </p>
                        <p style={{ margin: "4px 0", color: "#666" }}>
                           Username: @{user.username}
                        </p>
                     </li>
                  ))}
               </ul>
            ) : query.trim() && !loading ? (
               <p style={{ textAlign: "center", color: "#666" }}>
                  No users found for "{query}"
               </p>
            ) : null}
         </div>
      </div>
   );
}
```

### Weather Dashboard

```jsx
function WeatherDashboard() {
   const [weather, setWeather] = useState(null);
   const [loading, setLoading] = useState(true);
   const [error, setError] = useState(null);
   const [city, setCity] = useState("London");

   useEffect(() => {
      const fetchWeather = async () => {
         try {
            setLoading(true);
            setError(null);

            // Simulate weather API call
            await new Promise((resolve) => setTimeout(resolve, 1000));

            // Mock weather data
            const mockWeather = {
               city: city,
               temperature: Math.round(Math.random() * 30 + 5),
               condition: ["Sunny", "Cloudy", "Rainy", "Snowy"][
                  Math.floor(Math.random() * 4)
               ],
               humidity: Math.round(Math.random() * 40 + 30),
               windSpeed: Math.round(Math.random() * 20 + 5),
               lastUpdated: new Date().toLocaleTimeString(),
            };

            setWeather(mockWeather);
         } catch (err) {
            setError("Failed to fetch weather data");
         } finally {
            setLoading(false);
         }
      };

      fetchWeather();
   }, [city]);

   // Auto-refresh every 30 seconds
   useEffect(() => {
      const intervalId = setInterval(() => {
         if (weather) {
            setWeather((prev) => ({
               ...prev,
               temperature: Math.round(Math.random() * 30 + 5),
               lastUpdated: new Date().toLocaleTimeString(),
            }));
         }
      }, 30000);

      return () => clearInterval(intervalId);
   }, [weather]);

   const getWeatherIcon = (condition) => {
      const icons = {
         Sunny: "☀️",
         Cloudy: "☁️",
         Rainy: "🌧️",
         Snowy: "❄️",
      };
      return icons[condition] || "🌤️";
   };

   if (loading) {
      return (
         <div
            style={{
               textAlign: "center",
               padding: "40px",
               fontSize: "18px",
            }}
         >
            Loading weather data...
         </div>
      );
   }

   if (error) {
      return (
         <div
            style={{
               textAlign: "center",
               padding: "40px",
               color: "#dc3545",
               fontSize: "18px",
            }}
         >
            {error}
         </div>
      );
   }

   return (
      <div
         style={{
            maxWidth: "500px",
            margin: "0 auto",
            padding: "20px",
         }}
      >
         <h1 style={{ textAlign: "center", marginBottom: "30px" }}>
            Weather Dashboard
         </h1>

         <div style={{ marginBottom: "20px" }}>
            <label
               htmlFor='city-select'
               style={{
                  display: "block",
                  marginBottom: "8px",
                  fontWeight: "bold",
               }}
            >
               Select City:
            </label>
            <select
               id='city-select'
               value={city}
               onChange={(e) => setCity(e.target.value)}
               style={{
                  width: "100%",
                  padding: "10px",
                  border: "2px solid #ddd",
                  borderRadius: "8px",
                  fontSize: "16px",
               }}
            >
               <option value='London'>London</option>
               <option value='New York'>New York</option>
               <option value='Tokyo'>Tokyo</option>
               <option value='Paris'>Paris</option>
               <option value='Sydney'>Sydney</option>
            </select>
         </div>

         {weather && (
            <div
               style={{
                  border: "2px solid #007bff",
                  borderRadius: "12px",
                  padding: "30px",
                  backgroundColor: "#f8f9fa",
                  textAlign: "center",
               }}
            >
               <h2
                  style={{
                     margin: "0 0 20px 0",
                     color: "#333",
                  }}
               >
                  {weather.city}
               </h2>

               <div
                  style={{
                     fontSize: "4rem",
                     margin: "20px 0",
                  }}
               >
                  {getWeatherIcon(weather.condition)}
               </div>

               <div
                  style={{
                     fontSize: "3rem",
                     fontWeight: "bold",
                     color: "#007bff",
                     margin: "20px 0",
                  }}
               >
                  {weather.temperature}°C
               </div>

               <p
                  style={{
                     fontSize: "1.5rem",
                     color: "#666",
                     margin: "10px 0",
                  }}
               >
                  {weather.condition}
               </p>

               <div
                  style={{
                     display: "grid",
                     gridTemplateColumns: "1fr 1fr",
                     gap: "20px",
                     marginTop: "30px",
                  }}
               >
                  <div>
                     <strong>Humidity</strong>
                     <p>{weather.humidity}%</p>
                  </div>
                  <div>
                     <strong>Wind Speed</strong>
                     <p>{weather.windSpeed} km/h</p>
                  </div>
               </div>

               <small
                  style={{
                     color: "#999",
                     marginTop: "20px",
                     display: "block",
                  }}
               >
                  Last updated: {weather.lastUpdated}
               </small>
            </div>
         )}
      </div>
   );
}
```

## Multiple Effects Pattern

```jsx
function UserDashboard({ userId }) {
   const [user, setUser] = useState(null);
   const [posts, setPosts] = useState([]);
   const [comments, setComments] = useState([]);
   const [loading, setLoading] = useState({
      user: true,
      posts: true,
      comments: true,
   });

   // Effect 1: Fetch user data
   useEffect(() => {
      const fetchUser = async () => {
         try {
            setLoading((prev) => ({ ...prev, user: true }));
            const response = await fetch(
               `https://jsonplaceholder.typicode.com/users/${userId}`
            );
            const userData = await response.json();
            setUser(userData);
         } catch (error) {
            console.error("Failed to fetch user:", error);
         } finally {
            setLoading((prev) => ({ ...prev, user: false }));
         }
      };

      fetchUser();
   }, [userId]);

   // Effect 2: Fetch user's posts
   useEffect(() => {
      const fetchPosts = async () => {
         try {
            setLoading((prev) => ({ ...prev, posts: true }));
            const response = await fetch(
               `https://jsonplaceholder.typicode.com/posts?userId=${userId}`
            );
            const postsData = await response.json();
            setPosts(postsData);
         } catch (error) {
            console.error("Failed to fetch posts:", error);
         } finally {
            setLoading((prev) => ({ ...prev, posts: false }));
         }
      };

      fetchPosts();
   }, [userId]);

   // Effect 3: Update document title
   useEffect(() => {
      if (user) {
         document.title = `${user.name} - User Dashboard`;
      }

      return () => {
         document.title = "React App";
      };
   }, [user]);

   const isLoading = Object.values(loading).some(Boolean);

   return (
      <div style={{ maxWidth: "800px", margin: "0 auto", padding: "20px" }}>
         {loading.user ? (
            <div>Loading user...</div>
         ) : user ? (
            <div style={{ marginBottom: "30px" }}>
               <h1>{user.name}</h1>
               <p>Email: {user.email}</p>
               <p>Phone: {user.phone}</p>
            </div>
         ) : null}

         <h2>Posts ({posts.length})</h2>
         {loading.posts ? (
            <div>Loading posts...</div>
         ) : (
            <div>
               {posts.map((post) => (
                  <article
                     key={post.id}
                     style={{
                        border: "1px solid #ddd",
                        borderRadius: "8px",
                        padding: "16px",
                        marginBottom: "16px",
                     }}
                  >
                     <h3>{post.title}</h3>
                     <p>{post.body}</p>
                  </article>
               ))}
            </div>
         )}
      </div>
   );
}
```

## Performance Optimization

### Avoiding Unnecessary Effects

```jsx
// ❌ Bad: Effect runs on every render
function BadExample({ user }) {
   const [expensiveValue, setExpensiveValue] = useState(null);

   useEffect(() => {
      const result = expensiveCalculation(user);
      setExpensiveValue(result);
   }); // No dependency array

   return <div>{expensiveValue}</div>;
}

// ✅ Good: Effect only runs when user changes
function GoodExample({ user }) {
   const [expensiveValue, setExpensiveValue] = useState(null);

   useEffect(() => {
      const result = expensiveCalculation(user);
      setExpensiveValue(result);
   }, [user]); // Dependency array with user

   return <div>{expensiveValue}</div>;
}
```

## Common Pitfalls and Solutions

### 1. Missing Dependencies

```jsx
// ❌ Wrong: Missing dependency
function BadCounter() {
   const [count, setCount] = useState(0);

   useEffect(() => {
      const interval = setInterval(() => {
         setCount(count + 1); // This will always be 0 + 1
      }, 1000);

      return () => clearInterval(interval);
   }, []); // Missing 'count' dependency

   return <div>{count}</div>;
}

// ✅ Correct: Use functional update
function GoodCounter() {
   const [count, setCount] = useState(0);

   useEffect(() => {
      const interval = setInterval(() => {
         setCount((prevCount) => prevCount + 1); // Uses previous value
      }, 1000);

      return () => clearInterval(interval);
   }, []); // No dependencies needed

   return <div>{count}</div>;
}
```

### 2. Infinite Loops

```jsx
// ❌ Wrong: Creates infinite loop
function BadExample() {
   const [data, setData] = useState([]);

   useEffect(() => {
      setData([...data, "new item"]); // Creates new array reference
   }, [data]); // data changes on every effect run

   return <div>{data.length}</div>;
}

// ✅ Correct: Use functional update
function GoodExample() {
   const [data, setData] = useState([]);

   useEffect(() => {
      // Only add item once when component mounts
      setData((prevData) => [...prevData, "new item"]);
   }, []); // Empty dependency array

   return <div>{data.length}</div>;
}
```

## Exercise: Build a News Reader

Create a news reader application with the following features:

-  Fetch articles from an API
-  Search functionality
-  Category filtering
-  Favorites system with localStorage
-  Auto-refresh

```jsx
function NewsReader() {
   const [articles, setArticles] = useState([]);
   const [filteredArticles, setFilteredArticles] = useState([]);
   const [loading, setLoading] = useState(true);
   const [searchTerm, setSearchTerm] = useState("");
   const [selectedCategory, setSelectedCategory] = useState("all");
   const [favorites, setFavorites] = useState([]);

   const categories = [
      "all",
      "technology",
      "sports",
      "politics",
      "entertainment",
   ];

   // Load favorites from localStorage on mount
   useEffect(() => {
      const savedFavorites = localStorage.getItem("newsFavorites");
      if (savedFavorites) {
         setFavorites(JSON.parse(savedFavorites));
      }
   }, []);

   // Save favorites to localStorage when favorites change
   useEffect(() => {
      localStorage.setItem("newsFavorites", JSON.stringify(favorites));
   }, [favorites]);

   // Fetch articles on mount
   useEffect(() => {
      const fetchArticles = async () => {
         try {
            setLoading(true);

            // Simulate API call with mock data
            await new Promise((resolve) => setTimeout(resolve, 1000));

            const mockArticles = [
               {
                  id: 1,
                  title: "New React Features Released",
                  category: "technology",
                  summary: "React team announces new concurrent features...",
                  publishedAt: new Date().toISOString(),
                  author: "React Team",
               },
               {
                  id: 2,
                  title: "World Cup Finals",
                  category: "sports",
                  summary: "Exciting match between two great teams...",
                  publishedAt: new Date().toISOString(),
                  author: "Sports Desk",
               },
               {
                  id: 3,
                  title: "Election Results",
                  category: "politics",
                  summary: "Latest polling results show...",
                  publishedAt: new Date().toISOString(),
                  author: "Political Correspondent",
               },
            ];

            setArticles(mockArticles);
         } catch (error) {
            console.error("Failed to fetch articles:", error);
         } finally {
            setLoading(false);
         }
      };

      fetchArticles();
   }, []);

   // Filter articles when search term or category changes
   useEffect(() => {
      let filtered = articles;

      if (selectedCategory !== "all") {
         filtered = filtered.filter(
            (article) => article.category === selectedCategory
         );
      }

      if (searchTerm) {
         filtered = filtered.filter(
            (article) =>
               article.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
               article.summary.toLowerCase().includes(searchTerm.toLowerCase())
         );
      }

      setFilteredArticles(filtered);
   }, [articles, searchTerm, selectedCategory]);

   const toggleFavorite = (articleId) => {
      setFavorites((prev) =>
         prev.includes(articleId)
            ? prev.filter((id) => id !== articleId)
            : [...prev, articleId]
      );
   };

   if (loading) {
      return (
         <div style={{ textAlign: "center", padding: "40px" }}>
            <h2>Loading latest news...</h2>
         </div>
      );
   }

   return (
      <div style={{ maxWidth: "800px", margin: "0 auto", padding: "20px" }}>
         <h1>News Reader</h1>

         {/* Search and Filter Controls */}
         <div style={{ marginBottom: "30px" }}>
            <input
               type='text'
               placeholder='Search articles...'
               value={searchTerm}
               onChange={(e) => setSearchTerm(e.target.value)}
               style={{
                  width: "100%",
                  padding: "12px",
                  marginBottom: "15px",
                  border: "2px solid #ddd",
                  borderRadius: "8px",
                  fontSize: "16px",
               }}
            />

            <select
               value={selectedCategory}
               onChange={(e) => setSelectedCategory(e.target.value)}
               style={{
                  padding: "10px",
                  border: "2px solid #ddd",
                  borderRadius: "8px",
                  fontSize: "16px",
               }}
            >
               {categories.map((category) => (
                  <option key={category} value={category}>
                     {category.charAt(0).toUpperCase() + category.slice(1)}
                  </option>
               ))}
            </select>
         </div>

         {/* Articles List */}
         <div>
            {filteredArticles.length > 0 ? (
               filteredArticles.map((article) => (
                  <article
                     key={article.id}
                     style={{
                        border: "1px solid #ddd",
                        borderRadius: "12px",
                        padding: "20px",
                        marginBottom: "20px",
                        backgroundColor: "#f9f9f9",
                     }}
                  >
                     <div
                        style={{
                           display: "flex",
                           justifyContent: "space-between",
                           alignItems: "flex-start",
                        }}
                     >
                        <div style={{ flex: 1 }}>
                           <h3 style={{ margin: "0 0 10px 0", color: "#333" }}>
                              {article.title}
                           </h3>
                           <p
                              style={{
                                 color: "#666",
                                 lineHeight: "1.6",
                                 margin: "0 0 15px 0",
                              }}
                           >
                              {article.summary}
                           </p>
                           <div style={{ fontSize: "14px", color: "#999" }}>
                              <span>By {article.author}</span>
                              <span> • </span>
                              <span>{article.category}</span>
                              <span> • </span>
                              <span>
                                 {new Date(
                                    article.publishedAt
                                 ).toLocaleDateString()}
                              </span>
                           </div>
                        </div>

                        <button
                           onClick={() => toggleFavorite(article.id)}
                           style={{
                              background: "none",
                              border: "none",
                              fontSize: "24px",
                              cursor: "pointer",
                              marginLeft: "15px",
                           }}
                        >
                           {favorites.includes(article.id) ? "❤️" : "🤍"}
                        </button>
                     </div>
                  </article>
               ))
            ) : (
               <div
                  style={{
                     textAlign: "center",
                     padding: "40px",
                     color: "#666",
                  }}
               >
                  <p>No articles found matching your search criteria.</p>
               </div>
            )}
         </div>

         {/* Favorites Count */}
         <div
            style={{
               position: "fixed",
               bottom: "20px",
               right: "20px",
               backgroundColor: "#007bff",
               color: "white",
               padding: "10px 15px",
               borderRadius: "25px",
               fontSize: "14px",
            }}
         >
            ❤️ {favorites.length} favorites
         </div>
      </div>
   );
}
```

## Key Concepts Mastered

1. **useEffect Hook**: Managing side effects in function components
2. **Dependencies**: Controlling when effects run
3. **Cleanup**: Preventing memory leaks and canceling operations
4. **Data Fetching**: Making API calls and handling loading states
5. **Event Listeners**: Adding and removing DOM event listeners
6. **Timers**: Setting up and cleaning up intervals and timeouts
7. **Performance**: Optimizing effects for better performance

## Best Practices

1. **Always include dependencies** in the dependency array
2. **Use cleanup functions** for subscriptions, timers, and event listeners
3. **Separate concerns** with multiple useEffect hooks
4. **Use functional updates** when state depends on previous state
5. **Avoid infinite loops** by managing dependencies carefully
6. **Handle loading and error states** for better UX

## Summary

In this module, you've learned: ✅ useEffect hook fundamentals  
✅ Component lifecycle management  
✅ Data fetching patterns  
✅ Cleanup and memory management  
✅ Performance optimization techniques  
✅ Real-world side effect handling

Next up: Module 5 where we'll explore advanced React concepts like Context,
custom hooks, and performance optimization!

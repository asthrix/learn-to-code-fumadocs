---
title: "L4: Hide Navbar When Not Signed In"
description: "Implement conditional UI based on authentication state"
---

# Hide Navbar When Not Signed In

Let's implement conditional rendering based on authentication state so the Navbar only appears when users are signed in! ğŸ¨

## Why Hide the Navbar?

**Current problem:**

```
User NOT signed in
  â†’ Navbar still shows
  â†’ "Favorites" link visible
  â†’ But favorites require authentication!
  â†’ Confusing UX ğŸ˜•
```

**Better UX:**

```
User NOT signed in
  â†’ Hide Navbar
  â†’ Show sign-in page
  â†’ Clean, focused interface âœ¨

User signed in
  â†’ Show Navbar
  â†’ User can navigate
  â†’ Access authenticated features ğŸ‰
```

## Understanding Conditional Rendering

<Accordions>

<Accordion title="Conditional Rendering Patterns">

**Three common patterns:**

**1. If statement (early return):**

```jsx
function Component() {
  const { user } = useAuth();
  
  if (!user) {
    return null;  // Don't render anything
  }
  
  return <div>Content for signed-in users</div>;
}
```

**2. Ternary operator:**

```jsx
function Component() {
  const { user } = useAuth();
  
  return (
    <div>
      {user ? (
        <div>Signed in content</div>
      ) : (
        <div>Not signed in content</div>
      )}
    </div>
  );
}
```

**3. Logical AND (&&):**

```jsx
function Component() {
  const { user } = useAuth();
  
  return (
    <div>
      {user && <div>Only show if user exists</div>}
    </div>
  );
}
```

**Which to use?**

- **Early return:** When entire component shouldn't render
- **Ternary:** When showing different content for each state
- **Logical AND:** When showing something or nothing

</Accordion>

<Accordion title="Loading States Matter">

**Why check `isLoading`?**

```jsx
// âŒ Wrong: Flashes Navbar then hides it
function App() {
  const { user } = useAuth();
  
  return (
    <div>
      {user && <Navbar />}  {/* Flashes on load! */}
      <Routes>...</Routes>
    </div>
  );
}
```

**Timeline:**
```
0ms: App starts
    â†’ isLoading: true
    â†’ user: null
    â†’ No Navbar (correct!)

100ms: Token fetch complete
    â†’ isLoading: false
    â†’ user: { ... }
    â†’ Navbar appears
    â†’ Visual "pop" effect ğŸ˜•
```

**âœ… Correct: Show loading first**

```jsx
function App() {
  const { user, isLoading } = useAuth();
  
  if (isLoading) {
    return <LoadingSpinner />;  // Smooth experience
  }
  
  return (
    <div>
      {user && <Navbar />}
      <Routes>...</Routes>
    </div>
  );
}
```

**Better timeline:**
```
0ms: App starts
    â†’ isLoading: true
    â†’ Show spinner (clear feedback)

100ms: Token fetch complete
    â†’ isLoading: false
    â†’ user: { ... }
    â†’ Show app with Navbar
    â†’ Smooth transition âœ¨
```

</Accordion>

<Accordion title="Why Not Conditionally Render Routes?">

**You might think:**

```jsx
// âŒ Don't do this
function App() {
  const { user } = useAuth();
  
  return (
    <div>
      {user && <Navbar />}
      {user ? (
        <Routes>
          <Route path="/" element={<HomePage />} />
        </Routes>
      ) : (
        <Routes>
          <Route path="/sign-in" element={<SignInPage />} />
        </Routes>
      )}
    </div>
  );
}
```

**Problems:**

1. **Routes unmount/remount** - Loses route state
2. **No URL protection** - Users can manually navigate to any URL
3. **Complex logic** - Hard to maintain

**âœ… Better approach:**

```jsx
function App() {
  const { user } = useAuth();
  
  return (
    <div>
      {user && <Navbar />}
      <Routes>
        <Route path="/" element={<HomePage />} />
        <Route path="/sign-in" element={<SignInPage />} />
      </Routes>
    </div>
  );
}
```

Then protect individual routes with a `<Route>` guard component (we'll create this in Lesson 13).

</Accordion>

</Accordions>

## Update App Component

Add conditional rendering for the Navbar based on auth state:

```jsx title="src/App.jsx"
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import { AuthProvider } from '@/components/AuthProvider';
import HomePage from '@/pages/HomePage';
import FavoritesPage from '@/pages/FavoritesPage';
import NotFoundPage from '@/pages/NotFoundPage';
import Navbar from '@/components/Navbar';
import { useAuth } from '@/components/AuthProvider';

function AppContent() {
  const { user, isLoading } = useAuth();

  // Show loading spinner while checking authentication
  if (isLoading) {
    return (
      <div className="loading-container">
        <div className="spinner"></div>
        <p>Loading...</p>
      </div>
    );
  }

  return (
    <div className="app">
      {/* Only show Navbar if user is signed in */}
      {user && <Navbar />}
      
      <main className="main-content">
        <Routes>
          <Route path="/" element={<HomePage />} />
          <Route path="/favorites" element={<FavoritesPage />} />
          <Route path="*" element={<NotFoundPage />} />
        </Routes>
      </main>
    </div>
  );
}

function App() {
  return (
    <AuthProvider>
      <BrowserRouter>
        <AppContent />
      </BrowserRouter>
    </AuthProvider>
  );
}

export default App;
```

## Add Loading Styles

Add CSS for the loading spinner:

```css title="src/app/global.css"
/* Loading Container */
.loading-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 100vh;
  background: #f9fafb;
}

/* Spinner Animation */
.spinner {
  width: 48px;
  height: 48px;
  border: 4px solid #e5e7eb;
  border-top-color: #3b82f6;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

.loading-container p {
  margin-top: 1rem;
  color: #6b7280;
  font-size: 0.875rem;
}
```

## Understanding the Code

<Tabs items={['Component Split', 'Loading State', 'Conditional Navbar', 'Layout Adjustment']}>

<Tab value="Component Split">

**Why two components?**

```jsx
// AppContent uses useAuth()
function AppContent() {
  const { user, isLoading } = useAuth();  // âœ… Works!
  // ...
}

// App wraps with AuthProvider
function App() {
  return (
    <AuthProvider>
      <BrowserRouter>
        <AppContent />  {/* Can use useAuth */}
      </BrowserRouter>
    </AuthProvider>
  );
}
```

**Why not this?**

```jsx
// âŒ Won't work!
function App() {
  const { user } = useAuth();  // ERROR: Outside AuthProvider!
  
  return (
    <AuthProvider>
      {/* ... */}
    </AuthProvider>
  );
}
```

**Rule:** You can only use `useAuth()` **inside** components wrapped by `<AuthProvider>`.

**Solution:** Create `AppContent` inside the provider:

```
App (no auth access)
  â””â”€â”€ AuthProvider
      â””â”€â”€ BrowserRouter
          â””â”€â”€ AppContent (has auth access âœ…)
```

</Tab>

<Tab value="Loading State">

**Loading state check:**

```jsx
const { user, isLoading } = useAuth();

if (isLoading) {
  return (
    <div className="loading-container">
      <div className="spinner"></div>
      <p>Loading...</p>
    </div>
  );
}
```

**Why this matters:**

**Without loading check:**
```
User opens app
  â†’ isLoading: true, user: null
  â†’ Shows sign-in page (wrong!)
  â†’ 100ms later: user data arrives
  â†’ Switches to home page
  â†’ Jarring transition ğŸ˜•
```

**With loading check:**
```
User opens app
  â†’ isLoading: true
  â†’ Shows loading spinner
  â†’ 100ms later: user data arrives
  â†’ isLoading: false
  â†’ Shows home page with Navbar
  â†’ Smooth experience âœ¨
```

**User perception:**

```
Without loading: "Why did it flash the sign-in page?"
With loading: "App is checking my session, nice!"
```

</Tab>

<Tab value="Conditional Navbar">

**Conditional rendering:**

```jsx
{user && <Navbar />}
```

**How it works:**

**Logical AND evaluation:**

```jsx
// When user is null:
{null && <Navbar />}  â†’ null (nothing rendered)

// When user exists:
{{ id: 1, name: 'John' } && <Navbar />}  â†’ <Navbar /> (rendered!)
```

**JavaScript logic:**

```javascript
// Falsy values return first operand:
null && anything        â†’ null
undefined && anything   â†’ undefined
false && anything       â†’ false
0 && anything          â†’ 0
'' && anything         â†’ ''

// Truthy values return second operand:
{} && anything         â†’ anything
'text' && anything     â†’ anything
true && anything       â†’ anything
```

**In JSX:**

```jsx
// Falsy values (except 0) don't render:
{null}       â†’ (nothing)
{undefined}  â†’ (nothing)
{false}      â†’ (nothing)
{true}       â†’ (nothing)

// But 0 renders as "0":
{0}          â†’ "0" (careful!)

// Objects and components render:
{<Navbar />} â†’ Navbar component
```

**That's why this works:**

```jsx
{user && <Navbar />}

// user is null â†’ nothing rendered
// user is object â†’ Navbar rendered
```

</Tab>

<Tab value="Layout Adjustment">

**Layout without Navbar:**

```jsx
return (
  <div className="app">
    {/* No Navbar here */}
    <main className="main-content">
      <Routes>...</Routes>
    </main>
  </div>
);
```

**Layout with Navbar:**

```jsx
return (
  <div className="app">
    <Navbar />  {/* Takes up space */}
    <main className="main-content">
      <Routes>...</Routes>
    </main>
  </div>
);
```

**CSS handles both:**

```css
.app {
  display: flex;
  flex-direction: column;
  min-height: 100vh;
}

.main-content {
  flex: 1;  /* Takes remaining space */
  /* Whether Navbar exists or not */
}
```

**Result:**

```
With Navbar:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Navbar (60px)   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                 â”‚
â”‚ Main Content    â”‚ â† Fills rest
â”‚                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Without Navbar:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 â”‚
â”‚                 â”‚
â”‚ Main Content    â”‚ â† Fills all
â”‚                 â”‚
â”‚                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

</Tab>

</Tabs>

## Testing the Conditional Rendering

<Steps>

<Step>

**Refresh the page**

You should see:
1. Loading spinner (briefly)
2. No Navbar (since not signed in)
3. Routes still work (HomePage loads)

</Step>

<Step>

**Check browser console**

```javascript
// In AuthProvider useEffect:
No valid session: Request failed with status code 401

// This is expected - no user signed in yet
```

</Step>

<Step>

**Test with React DevTools**

Check AuthProvider state:
```javascript
user: null
token: null
isLoading: false
```

Navbar should NOT be in the component tree.

</Step>

<Step>

**Navigate between pages**

Try visiting:
- `/` - HomePage (works)
- `/favorites` - FavoritesPage (works)
- `/random` - NotFoundPage (works)

All routes work, but no Navbar visible.

</Step>

</Steps>

## User Experience Flow

<Tabs items={['First Visit', 'Return Visit (No Session)', 'Return Visit (Has Session)']}>

<Tab value="First Visit">

**Timeline:**

```
0ms: User opens app
  â†’ AuthProvider mounts
  â†’ isLoading: true
  â†’ Show loading spinner

100ms: Check for token
  â†’ API call to /auth/refresh
  â†’ 401 Unauthorized (no token)
  â†’ user: null, token: null
  â†’ isLoading: false

101ms: Render app
  â†’ No Navbar (user is null)
  â†’ Show routes normally
  â†’ HomePage visible

User sees:
  1. Brief loading spinner
  2. Homepage without Navbar
  3. Eventually will see sign-in prompt
```

</Tab>

<Tab value="Return Visit (No Session)">

**Timeline:**

```
0ms: User returns (session expired)
  â†’ AuthProvider mounts
  â†’ isLoading: true
  â†’ Show loading spinner

100ms: Check for token
  â†’ API call to /auth/refresh
  â†’ 401 Unauthorized (expired token)
  â†’ user: null, token: null
  â†’ isLoading: false

101ms: Render app
  â†’ No Navbar
  â†’ Show routes
  â†’ HomePage visible

User sees:
  â†’ Same as first visit
  â†’ Must sign in again
```

</Tab>

<Tab value="Return Visit (Has Session)">

**Timeline (we'll implement token fetch in next lessons):**

```
0ms: User returns (session valid)
  â†’ AuthProvider mounts
  â†’ isLoading: true
  â†’ Show loading spinner

100ms: Check for token
  â†’ API call to /auth/refresh
  â†’ 200 OK (valid token!)
  â†’ user: { id, name, email }
  â†’ token: "eyJhbG..."
  â†’ isLoading: false

101ms: Render app
  â†’ Navbar visible âœ…
  â†’ User data available
  â†’ Full app access

User sees:
  1. Brief loading spinner
  2. App with Navbar
  3. Still signed in! ğŸ‰
```

</Tab>

</Tabs>

## Common Loading Patterns

<Accordions>

<Accordion title="Skeleton Screens">

Instead of a spinner, show content placeholder:

```jsx
if (isLoading) {
  return (
    <div className="app">
      <div className="skeleton-navbar"></div>
      <div className="skeleton-content">
        <div className="skeleton-card"></div>
        <div className="skeleton-card"></div>
      </div>
    </div>
  );
}
```

**Benefits:**
- Feels faster (shows structure)
- Less jarring transition
- Better perceived performance

</Accordion>

<Accordion title="Delayed Loading Indicator">

Don't show spinner for fast loads:

```jsx
const [showSpinner, setShowSpinner] = useState(false);

useEffect(() => {
  // Only show spinner if loading takes > 200ms
  const timer = setTimeout(() => {
    if (isLoading) {
      setShowSpinner(true);
    }
  }, 200);
  
  return () => clearTimeout(timer);
}, [isLoading]);

if (isLoading && showSpinner) {
  return <LoadingSpinner />;
}
```

**Benefits:**
- No spinner flash for fast loads
- Better UX for good connections
- Still shows feedback for slow loads

</Accordion>

<Accordion title="Progressive Enhancement">

Show app immediately, update when loaded:

```jsx
return (
  <div className="app">
    {user && <Navbar />}
    
    <main className="main-content">
      {isLoading ? (
        <div className="inline-loading">
          Checking session...
        </div>
      ) : (
        <Routes>...</Routes>
      )}
    </main>
  </div>
);
```

**Benefits:**
- App shell visible immediately
- Routes load progressively
- Feels more responsive

</Accordion>

</Accordions>

## What We've Achieved

**Before this lesson:**
```
âœ… AuthProvider created
âœ… Added to App
âœ… Token fetch on mount
âŒ Navbar always visible (confusing)
```

**After this lesson:**
```
âœ… AuthProvider created
âœ… Added to App
âœ… Token fetch on mount
âœ… Navbar conditionally rendered
âœ… Loading state handled
âœ… Clean UX for signed-out users
```

## What's Next?

In Lesson 5, we'll create the `SignInPage` where users can actually sign in! We'll build:
1. Page layout
2. Form container
3. Error message display
4. Navigation after success

<Callout type="success">
**âœ… Lesson Complete!** The Navbar now only appears when users are signed in!
</Callout>

## Key Takeaways

- âœ… **Conditional rendering** shows/hides UI based on state
- âœ… **Loading states** prevent jarring transitions
- âœ… **Split components** allow using context hooks
- âœ… **Logical AND (&&)** perfect for show/hide pattern
- âœ… **User experience** improved with smooth loading feedback
- âœ… **Early returns** keep code clean and readable
- âœ… **isLoading check** essential for good UX

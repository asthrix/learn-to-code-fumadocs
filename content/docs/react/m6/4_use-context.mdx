---
title: "`useContext`"
description:
   "Create lightweight global state with the Context API and custom providers."
module: "M6"
lesson: "4"
difficulty: "intermediate"
duration: "30"
project_phase: "Global state"
prerequisites: ["/docs/react/m6/3_prop-drilling"]
learning_objectives:
   - "Design context providers for user preferences"
   - "Compose `useReducer` with Context for predictable updates"
   - "Expose ergonomic custom hooks for consumers"
   - "Avoid common performance pitfalls"
tags: ["context", "react", "state-management"]
---

import { Accordions, Accordion } from "@/components/accordion";

# `useContext`

## Learning Objectives

By the end of this lesson, you will:

-  [ ] Build Context providers with clear responsibilities.
-  [ ] Combine `useReducer` and Context for predictable state updates.
-  [ ] Provide custom hooks (`usePreferencesContext`) for consumers.
-  [ ] Memoise provider values to avoid re-render storms.

## Building a Preferences Context

```tsx
const PreferencesContext = createContext<PreferencesState | undefined>(
   undefined
);

type PreferencesAction =
   | { type: "setTheme"; payload: "light" | "dark" }
   | { type: "setDensity"; payload: "comfortable" | "compact" };

function preferencesReducer(
   state: PreferencesState,
   action: PreferencesAction
) {
   switch (action.type) {
      case "setTheme":
         return { ...state, theme: action.payload };
      case "setDensity":
         return { ...state, density: action.payload };
      default:
         return state;
   }
}

export function PreferencesProvider({
   children,
}: {
   children: React.ReactNode;
}) {
   const [state, dispatch] = useReducer(preferencesReducer, {
      theme: "light",
      density: "comfortable",
   });
   const value = useMemo(() => ({ state, dispatch }), [state]);
   return (
      <PreferencesContext.Provider value={value}>
         {children}
      </PreferencesContext.Provider>
   );
}
```

---

## Custom Hook Consumers

```tsx
export function usePreferencesContext() {
   const context = useContext(PreferencesContext);
   if (!context)
      throw new Error(
         "usePreferencesContext must be used within PreferencesProvider"
      );
   return context;
}
```

-  Guard against missing providers to avoid silent failures.
-  Memoise derived values with selectors inside the hook if needed.

---

## Performance Tips

-  Split providers: theme vs analytics flags if updates differ.
-  Memoise context value with `useMemo`.
-  Use selectors or `useSyncExternalStore` for large contexts.

<Accordions type='single' className='mt-4'>
   <Accordion title='TaskFlow Pro Adoption'>
      <p>Integrate the preferences context into the app shell.</p>

      ```tsx filename="src/app/layout.tsx"
      import { PreferencesProvider } from "@/context/PreferencesContext";

      export default function RootLayout({ children }: { children: React.ReactNode }) {
         return (
            <html lang='en'>
               <body>
                  <PreferencesProvider>{children}</PreferencesProvider>
               </body>
            </html>
         );
      }
      ```

   </Accordion>
</Accordions>

---

## ✅ Validation Checklist

-  [ ] Providers memoise their values and expose custom hooks.
-  [ ] Components use context hooks instead of prop drilling.
-  [ ] Tests or stories confirm behaviour without providers.

---

<div className='mt-8 flex justify-between'>
   <a
      href='/docs/react/m6/3_prop-drilling'
      className='text-sm font-medium text-muted-foreground hover:text-foreground'
   >
      ← Prop Drilling
   </a>
   <a
      href='/docs/react/m6/5_zustand-introduction'
      className='text-sm font-medium text-primary hover:text-primary/80'
   >
      Next · Zustand Introduction
   </a>
</div>

---
title: "Implementing Module 3"
description:
   "Connect TaskFlow Pro to the API, wire loading states, and ship optimistic
   CRUD."
module: "M3"
lesson: "10"
difficulty: "advanced"
duration: "60"
project_phase: "Data integration"
prerequisites: ["/docs/react-new/m3/9_data-fetching-best-practices"]
learning_objectives:
   - "Fetch tasks on mount with caching"
   - "Implement optimistic create, update, and delete"
   - "Display loading, empty, and error states"
   - "Log retries and failures for diagnostics"
tags: ["implementation", "data", "effects"]
---

import { Accordions, Accordion } from "@/components/accordion";

# Implementing Module 3

## Learning Objectives

By the end of this lesson, you will:

-  [ ] Fetch tasks via `useTasksState` with caching and retries.
-  [ ] Wire optimistic CRUD mutations with rollback.
-  [ ] Surface loading skeletons, error callouts, and empty states.
-  [ ] Add logging for API success/failure events.

## Project Context

Module 3 is where TaskFlow Pro feels real: data persists, filters sync with the
API, and the UI stays responsive during slow networks. Implementing these pieces
sets the stage for routing and performance optimizations in upcoming modules.

---

## Implementation Plan

1. Extend `useTasksState` with cached fetches and mutation helpers.
2. Update dashboard components to render skeletons, errors, and empty states.
3. Add optimistic updates for create, complete, rename, and delete actions.
4. Log API timing and retries to the console (future observability hooks).

---

## ‚úÖ Best Practices

### 1. Separate UI Concerns from Data Logic

**Why:** Components like `TaskComposer` stay declarative by delegating
persistence to the hook.

### 2. Provide Fine-Grained Loading States

**Why:** Users should distinguish between initial load, background refetch, and
mutation in progress.

---

## ‚ùå Common Mistakes

### 1. Forgetting to Handle Empty Lists

**Problem:** Blank screens confuse users when no tasks exist.

**Solution:** Render callouts explaining how to create the first task.

### 2. Swallowing Errors

**Problem:** Silent failures make debugging impossible.

**Solution:** Log errors and display a friendly message with retry instructions.

---

## üî® Implement in TaskFlow Pro

Follow these steps to deliver the Module 3 milestone:

1. Update `src/hooks/useTasksState.ts` with cached fetching, optimistic
   mutations, and retry logging.
2. In `src/components/tasks/TaskDashboard.tsx`, render loading skeletons
   (`Skeleton` component), empty state callouts, and error messages using the
   hook's state.
3. Instrument mutations with `console.info`/`console.error` (later replaced with
   analytics).
4. Ensure toolbar filters trigger refetches and scroll resets via refs.
5. Commit with `git commit -am "feat: integrate module 3 data layer"`.

<Accordions type='single' className='mt-4'>
   <Accordion title='Solution Walkthrough'>
      <p>
         Bring together the caching hook and UI states to ship the Module 3 experience.
      </p>

      ```tsx filename="src/hooks/useTasksState.ts"
      import { useCallback, useEffect, useMemo, useRef, useState } from "react";
      import { createTask, deleteTask, fetchTasks, updateTask } from "@/lib/api/tasks";
      import { getTasksFromCache, setTasksCache, invalidateTasksCache } from "@/lib/api/cache";
      import { retryWithBackoff } from "@/lib/api/retry";

      type UseTasksStateOptions = {
         initialStatus?: StatusFilter;
      };

      export function useTasksState(options: UseTasksStateOptions = {}) {
         const [tasks, setTasks] = useState<Task[]>([]);
         const [statusFilter, setStatusFilter] = useState<StatusFilter>(
            options.initialStatus ?? "all"
         );
         const [search, setSearch] = useState("");
         const [isLoading, setIsLoading] = useState(true);
         const [isMutating, setIsMutating] = useState(false);
         const [error, setError] = useState<string | null>(null);

         const cacheKey = useMemo(() => {
            const params = new URLSearchParams();
            if (statusFilter !== "all") params.set("status", statusFilter);
            if (search) params.set("search", search);
            return `tasks::${params.toString()}`;
         }, [statusFilter, search]);

         useEffect(() => {
            const cached = getTasksFromCache(cacheKey);
            if (cached) {
               setTasks(cached);
               setIsLoading(false);
            }

            const controller = new AbortController();
            const load = async () => {
               setIsLoading(true);
               setError(null);

               try {
                  const data = await fetchTasks(
                     {
                        status: statusFilter === "all" ? undefined : statusFilter,
                        search,
                     },
                     { signal: controller.signal }
                  );
                  setTasks(data);
                  setTasksCache(cacheKey, data);
                  console.info("[tasks.fetch] success", { cacheKey, count: data.length });
               } catch (error) {
                  if ((error as Error).name === "AbortError") return;
                  console.error("[tasks.fetch] failed", error);
                  setError((error as Error).message ?? "Unable to load tasks");
               } finally {
                  setIsLoading(false);
               }
            };

            const timeout = setTimeout(load, cached ? 0 : 160);
            return () => {
               controller.abort();
               clearTimeout(timeout);
            };
         }, [cacheKey, statusFilter, search]);

         const rollbackRef = useRef<Task[]>([]);

         const runMutation = useCallback(
            async <T extends Task | void>(label: string, operation: () => Promise<T>) => {
               setIsMutating(true);
               try {
                  return await retryWithBackoff(operation);
               } catch (error) {
                  console.error(`[${label}] failed`, error);
                  throw error;
               } finally {
                  setIsMutating(false);
               }
            },
            []
         );

         const handleCreateTask = useCallback(
            async (input: TaskInput) => {
               rollbackRef.current = tasks;
               const optimistic = createOptimisticTask(input);
               setTasks((previous) => {
                  const next = [optimistic, ...previous];
                  setTasksCache(cacheKey, next);
                  return next;
               });

               try {
                  const persisted = await runMutation("tasks.create", () => createTask(input));
                  setTasks((previous) => {
                     const next = previous.map((task) =>
                        task.id === optimistic.id ? persisted : task
                     );
                     setTasksCache(cacheKey, next);
                     return next;
                  });
               } catch (error) {
                  setTasks(rollbackRef.current);
                  setTasksCache(cacheKey, rollbackRef.current);
                  throw error;
               }
            },
            [cacheKey, runMutation, tasks]
         );

         const handleToggleStatus = useCallback(
            async (taskId: string) => {
               rollbackRef.current = tasks;
               const target = tasks.find((task) => task.id === taskId);
               if (!target) return;

               const optimistic = {
                  ...target,
                  status: target.status === "completed" ? "in-progress" : "completed",
               };

               setTasks((previous) => {
                  const next = previous.map((task) =>
                     task.id === taskId ? optimistic : task
                  );
                  setTasksCache(cacheKey, next);
                  return next;
               });

               try {
                  const persisted = await runMutation("tasks.toggle", () =>
                     updateTask(taskId, { status: optimistic.status })
                  );
                  setTasks((previous) => {
                     const next = previous.map((task) =>
                        task.id === taskId ? persisted : task
                     );
                     setTasksCache(cacheKey, next);
                     return next;
                  });
               } catch (error) {
                  setTasks(rollbackRef.current);
                  setTasksCache(cacheKey, rollbackRef.current);
               }
            },
            [cacheKey, runMutation, tasks]
         );

         const handleRenameTask = useCallback(
            async (taskId: string, title: string) => {
               rollbackRef.current = tasks;
               setTasks((previous) => {
                  const next = previous.map((task) =>
                     task.id === taskId ? { ...task, title } : task
                  );
                  setTasksCache(cacheKey, next);
                  return next;
               });

               try {
                  const persisted = await runMutation("tasks.rename", () =>
                     updateTask(taskId, { title })
                  );
                  setTasks((previous) => {
                     const next = previous.map((task) =>
                        task.id === taskId ? persisted : task
                     );
                     setTasksCache(cacheKey, next);
                     return next;
                  });
               } catch (error) {
                  setTasks(rollbackRef.current);
                  setTasksCache(cacheKey, rollbackRef.current);
               }
            },
            [cacheKey, runMutation, tasks]
         );

         const handleDeleteTask = useCallback(
            async (taskId: string) => {
               rollbackRef.current = tasks;
               setTasks((previous) => {
                  const next = previous.filter((task) => task.id !== taskId);
                  setTasksCache(cacheKey, next);
                  return next;
               });

               try {
                  await runMutation("tasks.delete", () => deleteTask(taskId));
                  invalidateTasksCache(cacheKey);
               } catch (error) {
                  setTasks(rollbackRef.current);
                  setTasksCache(cacheKey, rollbackRef.current);
               }
            },
            [cacheKey, runMutation, tasks]
         );

         const filteredTasks = useMemo(() => tasks, [tasks]);
         const stats = useMemo(() => calculateStats(tasks), [tasks]);

         return {
            tasks: filteredTasks,
            stats,
            statusFilter,
            setStatusFilter,
            search,
            setSearch,
            isLoading,
            isMutating,
            error,
            createTask: handleCreateTask,
            toggleTaskStatus: handleToggleStatus,
            renameTask: handleRenameTask,
            deleteTask: handleDeleteTask,
         };
      }
      ```

      ```tsx filename="src/components/tasks/TaskDashboard.tsx"
      import { Callout } from "fumadocs-ui/components/callout";
      import { Skeleton } from "@/components/ui/skeleton";

      export function TaskDashboard() {
         const {
            tasks,
            stats,
            statusFilter,
            setStatusFilter,
            search,
            setSearch,
            isLoading,
            isMutating,
            error,
            createTask,
            toggleTaskStatus,
            renameTask,
            deleteTask,
         } = useTasksState();

         return (
            <section className='space-y-6'>
               <Header stats={stats} />
               <TaskToolbar
                  status={statusFilter}
                  onStatusChange={setStatusFilter}
                  query={search}
                  onSearch={setSearch}
                  isLoading={isLoading}
               />
               {error ? (
                  <Callout type='error' title='Unable to load tasks'>
                     {error}
                  </Callout>
               ) : null}
               {isLoading ? (
                  <div className='space-y-3'>
                     {[...Array(3)].map((_, index) => (
                        <Skeleton key={index} className='h-24 rounded-xl' />
                     ))}
                  </div>
               ) : tasks.length === 0 ? (
                  <Callout type='info' title='No tasks yet'>
                     Create your first task to see progress here.
                  </Callout>
               ) : (
                  <TaskList
                     tasks={tasks}
                     onToggleStatus={toggleTaskStatus}
                     onRenameTask={renameTask}
                     onDeleteTask={deleteTask}
                     isMutating={isMutating}
                  />
               )}
               <TaskComposer onCreateTask={createTask} isSubmitting={isMutating} />
            </section>
         );
      }
      ```

      ```bash
      git add src/hooks/useTasksState.ts src/components/tasks/TaskDashboard.tsx
      git commit -m "feat: integrate module 3 data layer"
      ```

   </Accordion>
</Accordions>

#### Expected Result

TaskFlow Pro now loads data from the API, performs optimistic updates, and
communicates loading and error states clearly.

---

## ‚úÖ Validation Checklist

### Functionality

-  [ ] Initial load fetches tasks and caches them.
-  [ ] Create/update/delete actions update the UI instantly and persist.
-  [ ] Loading skeletons, empty states, and errors render appropriately.

### Code Quality

-  [ ] Mutations share retry logging via `runMutation`.
-  [ ] Cache updates stay in sync with state transitions.

### Understanding

-  [ ] You can describe how optimistic updates roll back on failure.
-  [ ] You can explain why caching keys include filter params.

### Project Integration

-  [ ] Dashboard components consume the hook without manual fetch logic.
-  [ ] Logs prepare for future observability integrations.

---

<div className='mt-8 flex justify-between'>
   <a
      href='/docs/react-new/m3/9_data-fetching-best-practices'
      className='text-sm font-medium text-muted-foreground hover:text-foreground'
   >
      ‚Üê Data Fetching Best Practices
   </a>
   <a
      href='/docs/react-new/m3/11_validation'
      className='text-sm font-medium text-primary hover:text-primary/80'
   >
      Next ¬∑ Validation
   </a>
</div>

---
title: "`useEffect` Deep Dive"
description:
   "Master dependency arrays, cleanup logic, and sequencing so effects stay
   predictable."
module: "M3"
lesson: "3"
difficulty: "intermediate"
duration: "30"
project_phase: "Data integration"
prerequisites: ["/docs/react-new/m3/2_effects-in-react"]
learning_objectives:
   - "Explain how dependency arrays control effect execution"
   - "Implement cleanup functions for network requests"
   - "Sequence multiple effects without race conditions"
   - "Apply these patterns to `useTasksState`"
tags: ["effects", "useEffect", "react"]
---

import { Accordions, Accordion } from "@/components/accordion";

# `useEffect` Deep Dive

## Learning Objectives

By the end of this lesson, you will:

-  [ ] Tune dependency arrays to run effects exactly when needed.
-  [ ] Use cleanup functions to abort in-flight work.
-  [ ] Sequence multiple effects without causing race conditions.
-  [ ] Embed the fetch lifecycle inside `useTasksState`.

## Project Context

TaskFlow Pro's dashboard must fetch tasks, handle optimistic updates, and
reconcile state with the server. Mismanaged effects lead to duplicate requests,
stale data, or flickers. Mastering `useEffect` mechanics avoids these pitfalls.

---

## Dependency Arrays

`useEffect` re-runs when any dependency changes. Using an empty array (`[]`)
runs once after mount. Include every value used inside the effect that comes
from the component scope.

### Basic Example

```tsx
useEffect(() => {
   console.log("Filters changed");
}, [filters.status, filters.search]);
```

### Practical Example

```tsx
useEffect(() => {
   if (!taskId) return;
   const controller = new AbortController();

   fetch(`/api/tasks/${taskId}`, { signal: controller.signal })
      .then((response) => response.json())
      .then(setTaskDetails)
      .catch((error) => {
         if (error.name !== "AbortError") {
            notifyError(error.message);
         }
      });

   return () => controller.abort();
}, [taskId]);
```

---

## Sequencing Effects

Avoid race conditions by tracking request identifiers or canceling previous
tasks.

```tsx
useEffect(() => {
   let isCurrent = true;

   async function load() {
      const latest = await fetchTasks();
      if (isCurrent) {
         setTasks(latest);
      }
   }

   load();

   return () => {
      isCurrent = false;
   };
}, [fetchTasks]);
```

---

## ‚úÖ Best Practices

### 1. Move Async Functions Inside the Effect

**Why:** Declaring async functions at the top level risks stale closures. Define
them inside the effect to capture the latest dependencies.

### 2. Treat Cleanup as First-Class

**Why:** Network calls and subscriptions must be cancelled when the component
unmounts or dependencies change. Return cleanup even if today's implementation
does nothing‚Äîfuture contributors will fill it in.

```tsx
useEffect(() => {
   const controller = new AbortController();
   // TODO: wire up fetch with controller
   return () => controller.abort();
}, []);
```

---

## ‚ùå Common Mistakes

### 1. Omitting Dependencies for Performance

**Problem:** Manually trimming dependencies causes stale data or missed updates.

**Solution:** Include all dependencies; if a function causes infinite loops,
memoize it with `useCallback` or move it outside the component.

### 2. Running Effects Conditionally

**Problem:** Returning early during render to avoid running the effect breaks
rules of hooks.

**Solution:** Guard inside the effect body (`if (!condition) return;`).

---

## üî® Implement in TaskFlow Pro

Add a data-fetching effect to `useTasksState`:

1. Open `src/hooks/useTasksState.ts`.
2. Import `useEffect` and a new helper `fetchTasks` (you'll implement it in
   Lesson 6).
3. Inside the hook, run `useEffect` once on mount to load tasks.
4. Use an `AbortController` to cancel the request on cleanup.
5. Store loading and error state so the UI can respond.
6. Commit with `git commit -am "feat: load tasks on mount"`.

<Accordions type='single' className='mt-4'>
   <Accordion title='Solution Walkthrough'>
      <p>
         Add a predictable fetch effect that loads tasks once and shares loading/error state with consumers.
      </p>

      ```tsx filename="src/hooks/useTasksState.ts"
      import { useEffect, useMemo, useState } from "react";
      import { fetchTasks } from "@/lib/api/tasks";

      export function useTasksState() {
         const [tasks, setTasks] = useState<Task[]>([]);
         const [statusFilter, setStatusFilter] = useState<StatusFilter>("all");
         const [search, setSearch] = useState("");
         const [isLoading, setIsLoading] = useState(true);
         const [error, setError] = useState<string | null>(null);

         useEffect(() => {
            const controller = new AbortController();

            async function loadTasks() {
               setIsLoading(true);
               setError(null);

               try {
                  const result = await fetchTasks({ signal: controller.signal });
                  setTasks(result);
               } catch (error) {
                  if ((error as Error).name !== "AbortError") {
                     setError((error as Error).message);
                  }
               } finally {
                  setIsLoading(false);
               }
            }

            loadTasks();

            return () => controller.abort();
         }, []);

         const filteredTasks = useMemo(
            () => filterTasks(tasks, { status: statusFilter, search }),
            [tasks, statusFilter, search]
         );

         return {
            tasks,
            filteredTasks,
            statusFilter,
            setStatusFilter,
            search,
            setSearch,
            isLoading,
            error,
            // existing mutation helpers go here
         };
      }
      ```

      ```bash
      git add src/hooks/useTasksState.ts
      git commit -m "feat: load tasks on mount"
      ```

   </Accordion>
</Accordions>

#### Expected Result

`useTasksState` now initializes TaskFlow Pro's dashboard by loading tasks once,
with cleanup ready for route changes.

---

## ‚úÖ Validation Checklist

### Functionality

-  [ ] Tasks load automatically on dashboard mount.
-  [ ] Loading and error states propagate to the UI.

### Code Quality

-  [ ] `useEffect` dependencies are complete and lint-clean.
-  [ ] Cleanup aborts the network request on unmount.

### Understanding

-  [ ] You can articulate why effects run after render.
-  [ ] You can prevent race conditions by tracking `isCurrent` or aborting.

### Project Integration

-  [ ] Hook consumers can read `isLoading` and `error`.
-  [ ] Future lessons (data fetching, caching) build on this foundation.

---

<div className='mt-8 flex justify-between'>
   <a
      href='/docs/react-new/m3/2_effects-in-react'
      className='text-sm font-medium text-muted-foreground hover:text-foreground'
   >
      ‚Üê Effects in React
   </a>
   <a
      href='/docs/react-new/m3/4_use-ref-hook'
      className='text-sm font-medium text-primary hover:text-primary/80'
   >
      Next ¬∑ `useRef` for DOM and Mutable Values
   </a>
</div>

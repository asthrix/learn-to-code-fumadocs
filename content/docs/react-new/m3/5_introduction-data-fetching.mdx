---
title: "Introduction to Data Fetching"
description:
   "Map TaskFlow Pro's API surface and decide how data flows between client and
   server."
module: "M3"
lesson: "5"
difficulty: "intermediate"
duration: "25"
project_phase: "Data integration"
prerequisites: ["/docs/react-new/m3/4_use-ref-hook"]
learning_objectives:
   - "Explain RESTful patterns relevant to TaskFlow Pro"
   - "Design the tasks API contract (CRUD + filtering)"
   - "Decide where to place data fetching logic"
   - "Prepare a mock server for local development"
tags: ["data", "api", "planning"]
---

import { Accordions, Accordion } from "@/components/accordion";

# Introduction to Data Fetching

## Learning Objectives

By the end of this lesson, you will:

-  [ ] Identify the HTTP endpoints TaskFlow Pro requires.
-  [ ] Decide how the client authenticates and handles errors.
-  [ ] Choose where to locate fetching logic in the project.
-  [ ] Prepare a mock server or JSON file so effects have data to consume.

## Project Context

Module 3 persists TaskFlow Pro data. Before writing code, define the API
contract so both the client (React) and server (Next.js route handler or
external service) agree on shapes, status codes, and error formats.

---

## Designing the Tasks API

Core operations:

-  **GET `/api/tasks`** ‚Üí list tasks (supports status filter, search query).
-  **POST `/api/tasks`** ‚Üí create a task.
-  **PATCH `/api/tasks/:id`** ‚Üí update title or completion.
-  **DELETE `/api/tasks/:id`** ‚Üí remove a task.

### Basic Example (Fetch Contract)

```json
{
   "id": "task_123",
   "title": "Draft copy",
   "description": "Write hero text",
   "status": "in-progress",
   "priority": "medium",
   "createdAt": "2025-10-18T12:00:00.000Z"
}
```

### Practical Example (Query Params)

```http
GET /api/tasks?status=completed&search=copy
```

---

## Where Should Fetching Live?

Options:

-  **Hooks (`useTasksState`)** centralize data logic and expose UI-friendly
   state.
-  **Services (`@/lib/api/tasks`)** encapsulate HTTP details (headers, errors).
-  **Components** should stay declarative‚Äîconsume hooks/services, don't fetch
   directly.

---

## ‚úÖ Best Practices

### 1. Define a Response Envelope

**Why:** Consistent success/error shapes simplify error handling.

```ts
export type ApiResponse<T> = {
   data: T;
   error?: { message: string; code?: string };
};
```

### 2. Mock Early, Swap Later

**Why:** A mock server or static JSON file keeps development unblocked before
the real backend is ready.

```ts
// mock/tasks.ts
export const mockTasks: Task[] = [
   {
      id: "task-1",
      title: "Draft requirements",
      status: "in-progress",
      priority: "medium",
   },
];
```

---

## ‚ùå Common Mistakes

### 1. Fetching Inside Multiple Components

**Problem:** Duplicate requests and inconsistent state.

**Solution:** Centralize fetches inside a hook or context and share the result.

### 2. Ignoring Error Shapes

**Problem:** UI cannot surface server errors predictably.

**Solution:** Define a consistent error response and map to UI states.

---

## üî® Implement in TaskFlow Pro

Set up the foundation for data fetching:

1. Create `src/lib/api/types.ts` with shared API types (`TaskDto`,
   `ApiResponse`).
2. Add `src/lib/api/mock.ts` exporting a `mockTasks` array and helper functions
   to simulate latency.
3. Update `notes/module-3-effects-plan.md` with API endpoint definitions and
   sample payloads.
4. Commit with `git commit -am "chore: define api contract"`.

<Accordions type='single' className='mt-4'>
   <Accordion title='Solution Walkthrough'>
      <p>
         Establish types and mock data now so future lessons focus on fetching mechanics instead of guessing shapes.
      </p>

      ```ts filename="src/lib/api/types.ts"
      export type TaskDto = {
         id: string;
         title: string;
         description: string;
         status: "todo" | "in-progress" | "completed";
         priority: "low" | "medium" | "high";
         createdAt: string;
         updatedAt: string;
      };

      export type ApiResponse<T> = {
         data: T;
         error?: { message: string; code?: string };
      };
      ```

      ```ts filename="src/lib/api/mock.ts"
      import type { TaskDto } from "./types";

      export const mockTasks: TaskDto[] = [
         {
            id: "task-1",
            title: "Draft Module 3 outline",
            description: "Plan effects and data fetching lessons",
            status: "in-progress",
            priority: "medium",
            createdAt: "2025-10-18T12:00:00.000Z",
            updatedAt: "2025-10-18T12:00:00.000Z",
         },
      ];

      export async function simulateNetwork<T>(value: T, delay = 320) {
         return new Promise<T>((resolve) => {
            setTimeout(() => resolve(value), delay);
         });
      }
      ```

      ```md filename="notes/module-3-effects-plan.md"
      ## API Contract
      - GET `/api/tasks` ‚Üí `{ data: TaskDto[] }`
      - POST `/api/tasks` ‚Üí `{ data: TaskDto }`
      - PATCH `/api/tasks/{id}` ‚Üí `{ data: TaskDto }`
      - DELETE `/api/tasks/{id}` ‚Üí `{ data: null }`
      ```

      ```bash
      git add src/lib/api/types.ts src/lib/api/mock.ts notes/module-3-effects-plan.md
      git commit -m "chore: define api contract"
      ```

   </Accordion>
</Accordions>

#### Expected Result

The API contract is documented, typed, and backed by mock data so you can
iterate without a live backend.

---

## ‚úÖ Validation Checklist

### Functionality

-  [ ] API types cover the fields TaskFlow Pro needs.
-  [ ] Mock data simulates at least one task.

### Code Quality

-  [ ] Types and mocks live in a dedicated `src/lib/api` folder.
-  [ ] Notes reference endpoints and payloads.

### Understanding

-  [ ] You can articulate the CRUD operations TaskFlow Pro requires.
-  [ ] You know where fetching logic will reside.

### Project Integration

-  [ ] Mock data unlocks future lessons without waiting on a backend.
-  [ ] Contracts align with the effect plan documented earlier.

---

<div className='mt-8 flex justify-between'>
   <a
      href='/docs/react-new/m3/4_use-ref-hook'
      className='text-sm font-medium text-muted-foreground hover:text-foreground'
   >
      ‚Üê `useRef` for DOM and Mutable Values
   </a>
   <a
      href='/docs/react-new/m3/6_data-fetching-part-1'
      className='text-sm font-medium text-primary hover:text-primary/80'
   >
      Next ¬∑ Data Fetching Part 1
   </a>
</div>

---
title: "Custom Components Patterns"
description:
   "Design memo-friendly components with flexible APIs and predictable renders."
module: "M5"
lesson: "7"
difficulty: "advanced"
duration: "35"
project_phase: "Performance"
prerequisites: ["/docs/react-new/m5/6_custom-hooks-best-practices"]
learning_objectives:
   - "Build components that compose custom hooks and memoisation"
   - "Adopt patterns that minimise prop churn and re-renders"
   - "Expose ergonomic APIs with slots, render props, or compound parts"
   - "Plan refactors that isolate slow UI paths"
tags: ["react", "components", "performance"]
---

import { Accordions, Accordion } from "@/components/accordion";

# Custom Components Patterns

## Learning Objectives

By the end of this lesson, you will:

-  [ ] Pair memoised hooks with thin presentation components.
-  [ ] Keep props stable with controllers and prop getters.
-  [ ] Offer flexible composition using compound components.
-  [ ] Identify subtrees that benefit from lazy loading.

## Project Context

TaskFlow Pro surfaces dense project data. Component patterns that respect hooks
and memoisation keep renders predictable while still supporting design needs.

---

## Pattern 1 ¬∑ Controller + View

Split logic (controller) from presentation (view) to stabilise props.

```tsx
function TaskListController({ projectId }: { projectId: string | null }) {
   const { tasks } = useProjectTasks(projectId);
   const filtered = useTaskFilters(tasks);
   return <TaskListView tasks={filtered.tasks} />;
}
```

-  Controller owns hooks and memoised data.
-  View receives serialisable props only.

---

## Pattern 2 ¬∑ Prop Getters

Provide helper functions that consumers spread onto elements.

```tsx
function useCollapsible(options: CollapsibleOptions) {
   const state = useInternalState(options);
   return {
      getTriggerProps: (props: ComponentProps<"button"> = {}) => ({
         ...props,
         onClick: composeHandlers(props.onClick, state.toggle),
         "aria-expanded": state.open,
      }),
      getContentProps: () => ({ hidden: !state.open }),
   };
}
```

-  Keeps DOM concerns inside the hook/component pair.
-  Consumers avoid re-implementing accessibility attributes.

---

## Pattern 3 ¬∑ Compound Components

Expose subcomponents that share context, minimising prop drilling.

```tsx
const ProjectCardContext = createContext<ProjectCardValue | null>(null);

function ProjectCard({ project, children }: ProjectCardProps) {
   const value = useMemo(() => ({ project }), [project.id]);
   return (
      <ProjectCardContext.Provider value={value}>
         <section className='rounded-lg border p-4'>{children}</section>
      </ProjectCardContext.Provider>
   );
}

ProjectCard.Header = function ProjectCardHeader() {
   const { project } = useRequiredContext(ProjectCardContext);
   return <h3 className='text-lg font-semibold'>{project.name}</h3>;
};
```

-  Context value is memoised by stable `project.id`.
-  Consumers compose `ProjectCard.Header`, `ProjectCard.Stats`, etc.

---

## üî® Implement in TaskFlow Pro

Strengthen component architecture:

1. Refactor `TaskList` into `TaskListController` + `TaskListView` under
   `src/components/tasks/`.
2. Introduce `ProjectCard` compound component with memoised context for
   dashboards.
3. Add `useCollapsible` prop getters to the existing `Accordion` implementation
   to standardise keyboard support.
4. Create `notes/module-5-performance-plan.md` (if missing) and capture chosen
   patterns under "Component Patterns".
5. Commit with `git commit -am "refactor: memo-friendly task components"`.

<Accordions type='single' className='mt-4'>
   <Accordion title='Solution Walkthrough'>
      <p>Refactor components so views render fast while controllers manage state.</p>

      ```tsx filename="src/components/tasks/TaskListController.tsx"
      import { memo } from "react";
      import { useProjectTasks } from "@/hooks/useProjectTasks";
      import { useTaskFilters } from "@/hooks/useTaskFilters";
      import { TaskListView } from "@/components/tasks/TaskListView";

      export const TaskListController = memo(function TaskListController({ projectId }: { projectId: string | null }) {
         const { tasks } = useProjectTasks(projectId);
         const filtered = useTaskFilters(tasks);
         return <TaskListView tasks={filtered.tasks} />;
      });
      ```

      ```tsx filename="src/components/dashboard/ProjectCard.tsx"
      import { createContext, useContext, useMemo } from "react";

      type ProjectCardContextValue = { project: Project };

      const ProjectCardContext = createContext<ProjectCardContextValue | null>(null);

      export function ProjectCard({ project, children }: ProjectCardProps) {
         const value = useMemo(() => ({ project }), [project.id, project]);
         return (
            <ProjectCardContext.Provider value={value}>{children}</ProjectCardContext.Provider>
         );
      }

      ProjectCard.Header = function ProjectCardHeader() {
         const { project } = useRequiredContext(ProjectCardContext);
         return <h3 className='text-lg font-semibold'>{project.name}</h3>;
      };
      ```

      ```md filename="notes/module-5-performance-plan.md"
      ## Component Patterns
      - Task list split into controller/view pairs
      - Project card compound component with memoised context
      - Collapsible hook exposes prop getters for accessibility
      ```

      ```bash
      git add src/components/tasks notes/module-5-performance-plan.md
      git commit -m "refactor: memo-friendly task components"
      ```

   </Accordion>
</Accordions>

#### Expected Result

Components provide ergonomic, memo-friendly APIs that compose cleanly with the
custom hooks introduced earlier in the module.

---

## ‚úÖ Validation Checklist

### Functionality

-  [ ] Controllers feed memoised data into lightweight views.
-  [ ] Compound components expose intuitive subcomponents.

### Code Quality

-  [ ] Context values are memoised by stable identifiers.
-  [ ] Prop getters keep accessibility attributes consistent.

### Understanding

-  [ ] You can explain when to pick controller/view vs compound patterns.
-  [ ] You know how prop getters reduce duplicate DOM logic.

### Project Integration

-  [ ] TaskFlow Pro dashboards rely on stable component trees.
-  [ ] Future modules can extend patterns without rewrites.

---

<div className='mt-8 flex justify-between'>
   <a
      href='/docs/react-new/m5/6_custom-hooks-best-practices'
      className='text-sm font-medium text-muted-foreground hover:text-foreground'
   >
      ‚Üê Custom Hooks Best Practices
   </a>
   <a
      href='/docs/react-new/m5/8_component-best-practices'
      className='text-sm font-medium text-primary hover:text-primary/80'
   >
      Next ¬∑ Component Best Practices
   </a>
</div>

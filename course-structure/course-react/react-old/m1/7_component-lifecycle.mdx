---
title: "Component Lifecycle"
description:
   "Understand how React components mount, update, and unmount in modern React."
module: "M1"
lesson: "7"
difficulty: "beginner"
duration: "20"
project_phase: "UI scaffolding"
prerequisites: ["/docs/react/m1/6_component-props"]
learning_objectives:
   - "Describe the lifecycle phases of a React component"
   - "Identify when effects run in React 18"
   - "Plan cleanup logic for TaskFlow Pro components"
   - "Recognise lifecycle implications in concurrent rendering"
tags: ["lifecycle", "react", "effects"]
---

import { Accordions, Accordion } from "@/components/accordion";

# Component Lifecycle

## Learning Objectives

By the end of this lesson, you will:

-  [ ] Explain the mount → update → unmount lifecycle.
-  [ ] Understand when `useEffect` runs in React 18 strict mode.
-  [ ] Plan cleanup logic for timers, subscriptions, or listeners.
-  [ ] Anticipate concurrent rendering nuances.

## Project Context

TaskFlow Pro will use effects for analytics, shortcuts, and persisted state.
Knowing the lifecycle prevents memory leaks and duplicated work.

---

## Lifecycle Phases

1. **Mount:** Component renders for the first time.
2. **Update:** Props or state change triggers re-render.
3. **Unmount:** Component removed from the tree.

### Basic Example

```tsx
useEffect(() => {
   console.log("mounted");
   return () => console.log("unmounted");
}, []);
```

### Practical Example

```tsx
export function KeyboardShortcuts() {
   useEffect(() => {
      const handleKey = (event: KeyboardEvent) => {
         if (event.key === "n" && event.metaKey) {
            event.preventDefault();
            // open quick add modal
         }
      };

      window.addEventListener("keydown", handleKey);
      return () => window.removeEventListener("keydown", handleKey);
   }, []);

   return null;
}
```

---

## React 18 Strict Mode

Strict mode intentionally double-invokes certain lifecycle methods (including
effects) in development to surface unsafe side effects. Always make effects
idempotent.

---

## ✅ Best Practices

### 1. Keep Effects Focused

**Why:** Narrow scope simplifies debugging.

```tsx
useEffect(() => {
   document.title = `${completed}/${total} tasks complete`;
}, [completed, total]);
```

### 2. Clean Up on Unmount

**Why:** Prevents event listeners or timers from persisting.

```tsx
return () => clearInterval(intervalId);
```

---

## ❌ Common Mistakes

### 1. Skipping Dependency Arrays

**Problem:** Effect runs on every render, causing loops.

```tsx
useEffect(() => {
   setState(data);
});
```

**Solution:** Provide dependency list or refactor logic.

### 2. Mutating State During Render

**Problem:** Causes inconsistent UI and warnings.

**Solution:** Use effects or event handlers for side effects.

---

## 🔨 Implement in TaskFlow Pro

### Task: Lifecycle Notes Component

1. Create `src/components/system/LifecycleLogger.tsx`.
2. Use `useEffect` to log mount and unmount events (development only).
3. Render the component beneath the dashboard header temporarily.
4. Document scenarios where this tool helps (e.g., verifying cleanup) in
   `notes/react-foundations.md`.
5. Commit with `git commit -am "chore: add lifecycle logger"`.

<Accordions type='single' className='mt-4'>
   <Accordion title='Solution Walkthrough'>
      <p>
         Create an internal logger that verifies mount/unmount behaviour without leaking
         into production builds.
      </p>

      ```tsx filename="src/components/system/LifecycleLogger.tsx"
      import { useEffect } from 'react';

      export function LifecycleLogger({ name = 'LifecycleLogger' }: { name?: string }) {
         useEffect(() => {
            if (!import.meta.env.DEV) return undefined;

            console.groupCollapsed(`[${name}] mounted`);
            console.log('Props and environment ready');
            console.groupEnd();

            return () => {
               console.groupCollapsed(`[${name}] unmounted`);
               console.log('Cleaned up listeners and timers');
               console.groupEnd();
            };
         }, [name]);

         return null;
      }
      ```

      ```tsx filename="src/App.tsx"
      import { LifecycleLogger } from '@/components/system/LifecycleLogger';

      export function App() {
         return (
            <DashboardShell>
               <LifecycleLogger name='DashboardShell' />
               {/* Existing dashboard content */}
            </DashboardShell>
         );
      }
      ```

      ```md filename="notes/react-foundations.md"
      ## Lifecycle Logger Usage

      - Toggle sidebar collapse to watch mount/unmount logs.
      - Verify effect cleanups before adding analytics or WebSocket code.
      - Remove component or guard with `import.meta.env.DEV` before production deploys.
      ```

      ```bash
      git add src/components/system/LifecycleLogger.tsx src/App.tsx notes/react-foundations.md
      git commit -m "chore: add lifecycle logger"
      ```

   </Accordion>
</Accordions>

#### Expected Result

Console logs confirm when components mount/unmount, making debugging easier
during future modules.

---

## ✅ Validation Checklist

### Functionality

-  [ ] Logger prints mount/unmount messages when toggling views.

### Code Quality

-  [ ] Effects include cleanup and dependency arrays.
-  [ ] Logger only runs in development (`if (import.meta.env.DEV)`).

### Understanding

-  [ ] You can describe why effects run twice in development.

### Project Integration

-  [ ] Notes mention removing or guarding the logger for production builds.

---

